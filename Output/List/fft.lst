###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       29/Nov/2024  17:57:36
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\IAR Systems\oh-in-pe-\fft.c
#    Command line =  
#        "C:\IAR Systems\oh-in-pe-\fft.c" -lC "C:\IAR
#        Systems\oh-in-pe-\Output\List" -o "C:\IAR
#        Systems\oh-in-pe-\Output\Obj" --debug --endian=little --cpu=Cortex-M7
#        -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5_2\arm\INC\c\DLib_Config_Full.h" -I
#        "C:\IAR Systems\oh-in-pe-\" -I "C:\IAR Systems\oh-in-pe-\Include\" -I
#        "C:\IAR Systems\oh-in-pe-\Include\CMSIS\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Inc\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Src\" -Ohz
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM7
#    Locale       =  Korean_Korea.949
#    List file    =  C:\IAR Systems\oh-in-pe-\Output\List\fft.lst
#    Object file  =  C:\IAR Systems\oh-in-pe-\Output\Obj\fft.o
#
###############################################################################

C:\IAR Systems\oh-in-pe-\fft.c
      1          #include "fft.h"
      2          
      3          #include <math.h>
      4          
      5          #include <stdio.h>
      6          #include <stdlib.h>
      7          
      8          
      9          #define M_PI 3.14159265358979
     10          
     11          /* ===== In-Place FFT ======================================================= */
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void ffti_f(complex_f data[], unsigned log2_N, fft_dir direction)
     14          {
   \                     ffti_f: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     15              ffti_shuffle_f(data, log2_N);
   \   00000008   0x.... 0x....      BL       ffti_shuffle_f
     16              ffti_evaluate_f(data, log2_N, direction);
   \   0000000C   0x4632             MOV      R2,R6
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000016   0x....             B.N      ffti_evaluate_f
     17          }
     18          

   \                                 In section .text, align 2, keep-with-next
     19          void ffti_copy_shuffle_f(complex_f src[], complex_f dst[], unsigned log2_N)
     20          {
     21              /*
     22               * Basic Bit-Reversal Scheme:
     23               *
     24               * The incrementing pattern operations used here correspond
     25               * to the logic operations of a synchronous counter.
     26               *
     27               * Incrementing a binary number simply flips a sequence of
     28               * least-significant bits, for example from 0111 to 1000.
     29               * So in order to compute the next bit-reversed index, we
     30               * have to flip a sequence of most-significant bits.
     31               */
     32          
     33              unsigned N = 1 << log2_N;   /* N */
   \                     ffti_copy_shuffle_f: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0xFA03 0xF202      LSL      R2,R3,R2
   \   00000006   0xB5F0             PUSH     {R4-R7,LR}
     34              unsigned Nd2 = N >> 1;      /* N/2 = number range midpoint */
   \   00000008   0x0853             LSRS     R3,R2,#+1
     35              unsigned Nm1 = N - 1;       /* N-1 = digit mask */
   \   0000000A   0x1E54             SUBS     R4,R2,#+1
     36              unsigned i;                 /* index for source element */
     37              unsigned j;                 /* index for next destination element */
     38          
     39              for (i = 0, j = 0; i < N; i++) {
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xE011             B.N      ??ffti_copy_shuffle_f_0
     40                  dst[j] = src[i];
   \                     ??ffti_copy_shuffle_f_1: (+1)
   \   00000012   0xEB00 0x0CC5      ADD      R12,R0,R5, LSL #+3
   \   00000016   0xEB01 0x07C6      ADD      R7,R1,R6, LSL #+3
   \   0000001A   0xEC9C 0x0A02      VLDM     R12,{S0-S1}
   \   0000001E   0xEC87 0x0A02      VSTM     R7,{S0-S1}
     41          
     42                  /*
     43                   * Find least significant zero bit
     44                   */
     45          
     46                  unsigned lszb = ~i & (i + 1);
     47          
     48                  /*
     49                   * Use division to bit-reverse the single bit so that we now have
     50                   * the most significant zero bit
     51                   *
     52                   * N = 2^r = 2^(m+1)
     53                   * Nd2 = N/2 = 2^m
     54                   * if lszb = 2^k, where k is within the range of 0...m, then
     55                   *     mszb = Nd2 / lszb
     56                   *          = 2^m / 2^k
     57                   *          = 2^(m-k)
     58                   *          = bit-reversed value of lszb
     59                   */
     60          
     61                  unsigned mszb = Nd2 / lszb;
     62          
     63                  /*
     64                   * Toggle bits with bit-reverse mask
     65                   */
     66          
     67                  unsigned bits = Nm1 & ~(mszb - 1);
     68                  j ^= bits;
   \   00000022   0x1C6F             ADDS     R7,R5,#+1
   \   00000024   0xEA27 0x0505      BIC      R5,R7,R5
   \   00000028   0xFBB3 0xF5F5      UDIV     R5,R3,R5
   \   0000002C   0x1E6D             SUBS     R5,R5,#+1
   \   0000002E   0xEA24 0x0505      BIC      R5,R4,R5
   \   00000032   0x406E             EORS     R6,R5,R6
     69              }
   \   00000034   0x463D             MOV      R5,R7
   \                     ??ffti_copy_shuffle_f_0: (+1)
   \   00000036   0x4295             CMP      R5,R2
   \   00000038   0xD3EB             BCC.N    ??ffti_copy_shuffle_f_1
     70          }
   \   0000003A   0xBDF0             POP      {R4-R7,PC}       ;; return
     71          
     72          
     73          

   \                                 In section .text, align 2, keep-with-next
     74          void ffti_shuffle_f(complex_f data[], unsigned log2_N)
     75          {
     76              /*
     77               * Basic Bit-Reversal Scheme:
     78               *
     79               * The incrementing pattern operations used here correspond
     80               * to the logic operations of a synchronous counter.
     81               *
     82               * Incrementing a binary number simply flips a sequence of
     83               * least-significant bits, for example from 0111 to 1000.
     84               * So in order to compute the next bit-reversed index, we
     85               * have to flip a sequence of most-significant bits.
     86               */
     87          
     88              unsigned N = 1 << log2_N;   /* N */
   \                     ffti_shuffle_f: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000006   0xB5F0             PUSH     {R4-R7,LR}
     89              unsigned Nd2 = N >> 1;      /* N/2 = number range midpoint */
   \   00000008   0x084A             LSRS     R2,R1,#+1
     90              unsigned Nm1 = N - 1;       /* N-1 = digit mask */
   \   0000000A   0x1E4B             SUBS     R3,R1,#+1
     91              unsigned i;                 /* index for array elements */
     92              unsigned j;                 /* index for next element swap location */
     93          
     94              for (i = 0, j = 0; i < N; i++) {
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE019             B.N      ??ffti_shuffle_f_0
     95                  if (j > i) {
   \                     ??ffti_shuffle_f_1: (+1)
   \   00000012   0x42A5             CMP      R5,R4
   \   00000014   0xD20D             BCS.N    ??ffti_shuffle_f_2
     96                      complex_f tmp = data[i];
   \   00000016   0xEB00 0x06C5      ADD      R6,R0,R5, LSL #+3
     97                      data[i] = data[j];
   \   0000001A   0xEB00 0x07C4      ADD      R7,R0,R4, LSL #+3
   \   0000001E   0xEC96 0x0A02      VLDM     R6,{S0-S1}
   \   00000022   0xEC97 0x1A02      VLDM     R7,{S2-S3}
   \   00000026   0xEC86 0x1A02      VSTM     R6,{S2-S3}
     98                      data[j] = tmp;
   \   0000002A   0xEB00 0x06C4      ADD      R6,R0,R4, LSL #+3
   \   0000002E   0xEC86 0x0A02      VSTM     R6,{S0-S1}
     99                  }
    100          
    101                  /*
    102                   * Find least significant zero bit
    103                   */
    104          
    105                  unsigned lszb = ~i & (i + 1);
    106          
    107                  /*
    108                   * Use division to bit-reverse the single bit so that we now have
    109                   * the most significant zero bit
    110                   *
    111                   * N = 2^r = 2^(m+1)
    112                   * Nd2 = N/2 = 2^m
    113                   * if lszb = 2^k, where k is within the range of 0...m, then
    114                   *     mszb = Nd2 / lszb
    115                   *          = 2^m / 2^k
    116                   *          = 2^(m-k)
    117                   *          = bit-reversed value of lszb
    118                   */
    119          
    120                  unsigned mszb = Nd2 / lszb;
    121          
    122                  /*
    123                   * Toggle bits with bit-reverse mask
    124                   */
    125          
    126                  unsigned bits = Nm1 & ~(mszb - 1);
    127                  j ^= bits;
   \                     ??ffti_shuffle_f_2: (+1)
   \   00000032   0x1C6E             ADDS     R6,R5,#+1
   \   00000034   0xEA26 0x0505      BIC      R5,R6,R5
   \   00000038   0xFBB2 0xF5F5      UDIV     R5,R2,R5
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xEA23 0x0505      BIC      R5,R3,R5
   \   00000042   0x406C             EORS     R4,R5,R4
    128              }
   \   00000044   0x4635             MOV      R5,R6
   \                     ??ffti_shuffle_f_0: (+1)
   \   00000046   0x428D             CMP      R5,R1
   \   00000048   0xD3E3             BCC.N    ??ffti_shuffle_f_1
    129          }
   \   0000004A   0xBDF0             POP      {R4-R7,PC}       ;; return
    130          
    131          
    132          

   \                                 In section .text, align 4, keep-with-next
    133          void ffti_evaluate_f(complex_f data[], unsigned log2_N, fft_dir direction)
    134          {
   \                     ffti_evaluate_f: (+1)
   \   00000000   0xE92D 0x4BF0      PUSH     {R4-R9,R11,LR}
   \   00000004   0x460D             MOV      R5,R1
    135              unsigned N;
    136              unsigned r;
    137              unsigned m, md2;
    138              unsigned n, k;
    139              unsigned i_e, i_o;
    140              double theta_2pi;
    141              double theta;       /* Use double for precision */
    142              complex_d Wm, Wmk;  /* Use double for precision */
    143              complex_d u, t;     /* Use double for precision */
    144          
    145              N = 1 << log2_N;
   \   00000006   0x2601             MOVS     R6,#+1
    146              theta_2pi = (direction == FFT_FORWARD) ? -M_PI : M_PI;
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xED2D 0x8B06      VPUSH    {D8-D10}
   \   00000010   0xFA06 0xF805      LSL      R8,R6,R5
   \   00000014   0xBF0C             ITE      EQ 
   \   00000016   0xED9F 0x....      VLDREQ.W D8,??DataTable2
   \   0000001A   0xED9F 0x....      VLDRNE.W D8,??DataTable2_1
    147              theta_2pi *= 2;
    148          
    149              for (r = 1; r <= log2_N; r++)
   \   0000001E   0x2701             MOVS     R7,#+1
   \   00000020   0xE000             B.N      ??ffti_evaluate_f_0
   \                     ??ffti_evaluate_f_1: (+1)
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   \                     ??ffti_evaluate_f_0: (+1)
   \   00000024   0x42BD             CMP      R5,R7
   \   00000026   0xD36D             BCC.N    ??ffti_evaluate_f_2
    150              {
    151                  m = 1 << r;
   \   00000028   0xFA06 0xF907      LSL      R9,R6,R7
    152                  md2 = m >> 1;
    153                  theta = theta_2pi / m;
    154                  Wm.re = cos(theta);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xEE00 0x9A10      VMOV     S0,R9
   \   00000032   0xEEB8 0x0B40      VCVT.F64.U32 D0,S0
   \   00000036   0xEE88 0xAB00      VDIV.F64 D10,D8,D0
   \   0000003A   0xEEB0 0x0B4A      VMOV.F64 D0,D10
   \   0000003E   0x.... 0x....      BL       __iar_Sin
   \   00000042   0xEEB0 0x9B40      VMOV.F64 D9,D0
    155                  Wm.im = sin(theta);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xEEB0 0x0B4A      VMOV.F64 D0,D10
   \   0000004C   0x.... 0x....      BL       __iar_Sin
    156                  for (n = 0; n < N; n += m)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE04F             B.N      ??ffti_evaluate_f_3
    157                  {
    158                      Wmk.re = 1.f;
    159                      Wmk.im = 0.f;
    160                      for (k = 0; k < md2; k++)
    161                      {
    162                          i_e = n + k;
   \                     ??ffti_evaluate_f_4: (+1)
   \   00000054   0x180A             ADDS     R2,R1,R0
    163                          i_o = i_e + md2;
    164                          u.re = data[i_e].re;
    165                          u.im = data[i_e].im;
    166                          t.re = complex_mul_re(Wmk.re, Wmk.im, data[i_o].re, data[i_o].im);
    167                          t.im = complex_mul_im(Wmk.re, Wmk.im, data[i_o].re, data[i_o].im);
    168                          data[i_e].re = u.re + t.re;
    169                          data[i_e].im = u.im + t.im;
    170                          data[i_o].re = u.re - t.re;
    171                          data[i_o].im = u.im - t.im;
    172                          t.re = complex_mul_re(Wmk.re, Wmk.im, Wm.re, Wm.im);
    173                          t.im = complex_mul_im(Wmk.re, Wmk.im, Wm.re, Wm.im);
    174                          Wmk = t;
    175                      }
   \   00000056   0x1C49             ADDS     R1,R1,#+1
   \   00000058   0xEB02 0x0C59      ADD      R12,R2,R9, LSR #+1
   \   0000005C   0xEB04 0x0BCC      ADD      R11,R4,R12, LSL #+3
   \   00000060   0xEB04 0x0ECC      ADD      LR,R4,R12, LSL #+3
   \   00000064   0xEB04 0x03C2      ADD      R3,R4,R2, LSL #+3
   \   00000068   0xEB04 0x02C2      ADD      R2,R4,R2, LSL #+3
   \   0000006C   0xED9B 0x7A00      VLDR     S14,[R11, #0]
   \   00000070   0xED9E 0x6A01      VLDR     S12,[LR, #+4]
   \   00000074   0xEEB7 0x5AC7      VCVT.F64.F32 D5,S14
   \   00000078   0xED93 0x3A00      VLDR     S6,[R3, #0]
   \   0000007C   0xEE25 0x5B01      VMUL.F64 D5,D5,D1
   \   00000080   0xEEB7 0xAAC6      VCVT.F64.F32 D10,S12
   \   00000084   0xEEB7 0x6AC6      VCVT.F64.F32 D6,S12
   \   00000088   0xEE26 0x6B01      VMUL.F64 D6,D6,D1
   \   0000008C   0xEEB7 0x7AC7      VCVT.F64.F32 D7,S14
   \   00000090   0xEEB7 0x3AC3      VCVT.F64.F32 D3,S6
   \   00000094   0xEE0A 0x5B42      VMLS.F64 D5,D10,D2
   \   00000098   0xEE07 0x6B02      VMLA.F64 D6,D7,D2
   \   0000009C   0xEE33 0x7B05      VADD.F64 D7,D3,D5
   \   000000A0   0xED93 0x4A01      VLDR     S8,[R3, #+4]
   \   000000A4   0xEEB7 0x7BC7      VCVT.F32.F64 S14,D7
   \   000000A8   0xEEB7 0x4AC4      VCVT.F64.F32 D4,S8
   \   000000AC   0xED82 0x7A00      VSTR     S14,[R2, #0]
   \   000000B0   0xEB04 0x02CC      ADD      R2,R4,R12, LSL #+3
   \   000000B4   0xEE34 0x7B06      VADD.F64 D7,D4,D6
   \   000000B8   0xEEB7 0x7BC7      VCVT.F32.F64 S14,D7
   \   000000BC   0xEE33 0x3B45      VSUB.F64 D3,D3,D5
   \   000000C0   0xED83 0x7A01      VSTR     S14,[R3, #+4]
   \   000000C4   0xEEB7 0x3BC3      VCVT.F32.F64 S6,D3
   \   000000C8   0xED82 0x3A00      VSTR     S6,[R2, #0]
   \   000000CC   0xEE34 0x3B46      VSUB.F64 D3,D4,D6
   \   000000D0   0xEEB7 0x3BC3      VCVT.F32.F64 S6,D3
   \   000000D4   0xED8E 0x3A01      VSTR     S6,[LR, #+4]
   \   000000D8   0xEE21 0x3B00      VMUL.F64 D3,D1,D0
   \   000000DC   0xEE21 0x1B09      VMUL.F64 D1,D1,D9
   \   000000E0   0xEE02 0x3B09      VMLA.F64 D3,D2,D9
   \   000000E4   0xEE02 0x1B40      VMLS.F64 D1,D2,D0
   \   000000E8   0xEEB0 0x2B43      VMOV.F64 D2,D3
   \                     ??ffti_evaluate_f_5: (+1)
   \   000000EC   0xEBB1 0x0F59      CMP      R1,R9, LSR #+1
   \   000000F0   0xD3B0             BCC.N    ??ffti_evaluate_f_4
   \   000000F2   0x4448             ADD      R0,R9,R0
   \                     ??ffti_evaluate_f_3: (+1)
   \   000000F4   0x4540             CMP      R0,R8
   \   000000F6   0xD294             BCS.N    ??ffti_evaluate_f_1
   \   000000F8   0xEEB7 0x1B00      VMOV.F64 D1,#1.0
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0xED9F 0x....      VLDR.W   D2,??DataTable3
   \   00000102   0xE7F3             B.N      ??ffti_evaluate_f_5
    176                  }
    177              }
    178          }
   \                     ??ffti_evaluate_f_2: (+1)
   \   00000104   0xECBD 0x8B06      VPOP     {D8-D10}
   \   00000108   0xE8BD 0x8BF0      POP      {R4-R9,R11,PC}   ;; return
    179          
    180          
    181          
    182          /* ===== Recursive FFT ====================================================== */
    183          
    184          
    185          

   \                                 In section .text, align 4, keep-with-next
    186          void fftr_f(complex_f data[], unsigned log2_N, fft_dir direction)
    187          {
   \                     fftr_f: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    188              if (log2_N > 0)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   0000000C   0x4615             MOV      R5,R2
   \   0000000E   0xD073             BEQ.N    ??fftr_f_0
    189              {
    190                  unsigned log2_Nd2;
    191                  unsigned Nd2;
    192                  unsigned k;
    193                  unsigned kpNd2;
    194                  complex_f *evn, *odd;
    195                  double theta_pi;
    196                  double theta;       /* Use double for precision */
    197                  complex_d WN, WNk;  /* Use double for precision */
    198                  complex_d u, t;     /* Use double for precision */
    199          
    200                  log2_Nd2 = log2_N - 1;
   \   00000010   0x1E4E             SUBS     R6,R1,#+1
    201                  Nd2 = 1 << log2_Nd2;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xFA00 0xF706      LSL      R7,R0,R6
    202          
    203                  evn = malloc(Nd2 * sizeof(complex_f));
   \   00000018   0x00F8             LSLS     R0,R7,#+3
   \   0000001A   0x.... 0x....      BL       malloc
   \   0000001E   0x4680             MOV      R8,R0
    204                  odd = malloc(Nd2 * sizeof(complex_f));
   \   00000020   0x00F8             LSLS     R0,R7,#+3
   \   00000022   0x.... 0x....      BL       malloc
   \   00000026   0x4681             MOV      R9,R0
    205          
    206                  for (k = 0; k < Nd2; k++)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE011             B.N      ??fftr_f_1
    207                  {
    208                      evn[k] = data[2*k];
   \                     ??fftr_f_2: (+1)
   \   0000002C   0xEB04 0x1300      ADD      R3,R4,R0, LSL #+4
   \   00000030   0xEB08 0x02C0      ADD      R2,R8,R0, LSL #+3
    209                      odd[k] = data[2*k+1];
   \   00000034   0xEB04 0x1100      ADD      R1,R4,R0, LSL #+4
   \   00000038   0xEC93 0x0A02      VLDM     R3,{S0-S1}
   \   0000003C   0xEC82 0x0A02      VSTM     R2,{S0-S1}
   \   00000040   0xEB09 0x02C0      ADD      R2,R9,R0, LSL #+3
   \   00000044   0x3108             ADDS     R1,R1,#+8
    210                  }
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xEC91 0x0A02      VLDM     R1,{S0-S1}
   \   0000004C   0xEC82 0x0A02      VSTM     R2,{S0-S1}
   \                     ??fftr_f_1: (+1)
   \   00000050   0x42B8             CMP      R0,R7
   \   00000052   0xD3EB             BCC.N    ??fftr_f_2
    211          
    212                  fftr_f(evn, log2_Nd2, direction);
   \   00000054   0x462A             MOV      R2,R5
   \   00000056   0x4631             MOV      R1,R6
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0xF7FF 0xFFD1      BL       fftr_f
    213                  fftr_f(odd, log2_Nd2, direction);
   \   0000005E   0x462A             MOV      R2,R5
   \   00000060   0x4631             MOV      R1,R6
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0xF7FF 0xFFCC      BL       fftr_f
    214          
    215                  theta_pi = (direction == FFT_FORWARD) ? -M_PI : M_PI;
   \   00000068   0x2D00             CMP      R5,#+0
    216                  theta = theta_pi / Nd2;  /* - (2 * M_PI) / N */
   \   0000006A   0xEE01 0x7A10      VMOV     S2,R7
   \   0000006E   0xEEB8 0x1B41      VCVT.F64.U32 D1,S2
   \   00000072   0xBF0C             ITE      EQ 
   \   00000074   0xED9F 0x....      VLDREQ.W D0,??DataTable3_1
   \   00000078   0xED9F 0x....      VLDRNE.W D0,??DataTable3_2
   \   0000007C   0xEE80 0x9B01      VDIV.F64 D9,D0,D1
    217                  WN.re = cos(theta);
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000086   0x.... 0x....      BL       ?Subroutine1
    218                  WN.im = sin(theta);
    219          
    220                  WNk.re = 1.f;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000008A   0x.... 0x....      BL       ?Subroutine2
    221                  WNk.im = 0.f;
    222                  for (k = 0; k < Nd2; k++)
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000008E   0xE027             B.N      ??CrossCallReturnLabel_0
    223                  {
    224                      kpNd2 = k + Nd2;
    225          
    226                      u.re = evn[k].re;
   \                     ??fftr_f_3: (+1)
   \   00000090   0xEB08 0x01C0      ADD      R1,R8,R0, LSL #+3
   \   00000094   0xED91 0x3A00      VLDR     S6,[R1, #0]
   \   00000098   0xEEB7 0x3AC3      VCVT.F64.F32 D3,S6
    227                      u.im = evn[k].im;
   \   0000009C   0xED91 0x4A01      VLDR     S8,[R1, #+4]
   \   000000A0   0xEB09 0x01C0      ADD      R1,R9,R0, LSL #+3
   \   000000A4   0xEEB7 0x4AC4      VCVT.F64.F32 D4,S8
   \   000000A8   0xEDD1 0x6A00      VLDR     S13,[R1, #0]
   \   000000AC   0xEEB7 0x5AE6      VCVT.F64.F32 D5,S13
   \   000000B0   0xED91 0x6A01      VLDR     S12,[R1, #+4]
    228                      t.re = complex_mul_re(WNk.re, WNk.im, odd[k].re, odd[k].im);
    229                      t.im = complex_mul_im(WNk.re, WNk.im, odd[k].re, odd[k].im);
    230                      data[k].re = u.re + t.re;
   \   000000B4   0xEB04 0x01C0      ADD      R1,R4,R0, LSL #+3
   \   000000B8   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \   000000BC   0xED81 0x6A00      VSTR     S12,[R1, #0]
    231                      data[k].im = u.im + t.im;
   \   000000C0   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000C4   0x1839             ADDS     R1,R7,R0
   \   000000C6   0xEB04 0x02C1      ADD      R2,R4,R1, LSL #+3
    232                      data[kpNd2].re = u.re - t.re;
    233                      data[kpNd2].im = u.im - t.im;
    234          
    235                      t.re = complex_mul_re(WNk.re, WNk.im, WN.re, WN.im);
    236                      t.im = complex_mul_im(WNk.re, WNk.im, WN.re, WN.im);
    237                      WNk = t;
    238                  }
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \   000000CC   0xEE33 0x3B45      VSUB.F64 D3,D3,D5
   \   000000D0   0xEEB7 0x3BC3      VCVT.F32.F64 S6,D3
   \   000000D4   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   000000D8   0xED82 0x3A00      VSTR     S6,[R2, #0]
   \   000000DC   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000E0   0x42B8             CMP      R0,R7
   \   000000E2   0xD3D5             BCC.N    ??fftr_f_3
    239          
    240                  free(evn);
   \   000000E4   0x4640             MOV      R0,R8
   \   000000E6   0x.... 0x....      BL       free
    241                  free(odd);
   \   000000EA   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000000EE   0x4648             MOV      R0,R9
   \   000000F0   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000000F4   0x.... 0x....      B.W      free
    242              }
    243          }
   \                     ??fftr_f_0: (+1)
   \   000000F8   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000000FC   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xEE34 0x6B07      VADD.F64 D6,D4,D7
   \   00000004   0xEEB7 0x6BC6      VCVT.F32.F64 S12,D6
   \   00000008   0xED81 0x6A01      VSTR     S12,[R1, #+4]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xEE25 0x5B01      VMUL.F64 D5,D5,D1
   \   00000004   0xEEB7 0x7AC6      VCVT.F64.F32 D7,S12
   \   00000008   0xEE07 0x5B42      VMLS.F64 D5,D7,D2
   \   0000000C   0xEEB7 0x7AC6      VCVT.F64.F32 D7,S12
   \   00000010   0xEE27 0x7B01      VMUL.F64 D7,D7,D1
   \   00000014   0xEEB7 0x6AE6      VCVT.F64.F32 D6,S13
   \   00000018   0xEE06 0x7B02      VMLA.F64 D7,D6,D2
   \   0000001C   0xEE33 0x6B05      VADD.F64 D6,D3,D5
   \   00000020   0xEEB7 0x6BC6      VCVT.F32.F64 S12,D6
   \   00000024   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xEEB7 0x1B00      VMOV.F64 D1,#1.0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xED9F 0x....      VLDR.W   D2,??DataTable3
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xEEB0 0x8B40      VMOV.F64 D8,D0
   \   00000004   0x2000             MOVS     R0,#+0
   \                     ??Subroutine1_0: (+1)
   \   00000006   0xEEB0 0x0B49      VMOV.F64 D0,D9
   \   0000000A   0x.... 0x....      B.W      __iar_Sin

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xEE34 0x3B47      VSUB.F64 D3,D4,D7
   \   00000004   0xEEB7 0x3BC3      VCVT.F32.F64 S6,D3
   \   00000008   0xED81 0x3A01      VSTR     S6,[R1, #+4]
   \   0000000C   0xEE21 0x3B00      VMUL.F64 D3,D1,D0
   \   00000010   0xEE21 0x1B08      VMUL.F64 D1,D1,D8
   \   00000014   0xEE02 0x3B08      VMLA.F64 D3,D2,D8
   \   00000018   0xEE02 0x1B40      VMLS.F64 D1,D2,D0
   \   0000001C   0xEEB0 0x2B43      VMOV.F64 D2,D3
   \   00000020   0x4770             BX       LR
    244          
    245          
    246          
    247          /* ===== Recursive FFT, user-supplied scratchpad buffer ===================== */
    248          
    249          
    250          
    251          #if 0
    252          
    253          /*
    254           * A more efficient version of the fftr_f() implementation, where a
    255           * user-supplied buffer is used to hold the even/odd decompositions
    256           */
    257          
    258          void fftrb_f(complex_f data[], unsigned log2_N, fft_dir direction, complex_f scratch[])
    259          {
    260          
    261              if (log2_N > 0)
    262              {
    263                  unsigned log2_Nd2;
    264                  unsigned Nd2;
    265                  unsigned k;
    266                  unsigned kpNd2;
    267                  complex_f *evn, *odd;
    268                  double theta_pi;
    269                  double theta;       /* Use double for precision */
    270                  complex_d WN, WNk;  /* Use double for precision */
    271                  complex_d u, t;     /* Use double for precision */
    272          
    273                  log2_Nd2 = log2_N - 1;
    274                  Nd2 = 1 << log2_Nd2;
    275          
    276                  evn = scratch;
    277                  odd = scratch + Nd2;
    278          
    279                  for (k = 0; k < Nd2; k++)
    280                  {
    281                      evn[k] = data[2*k];
    282                      odd[k] = data[2*k+1];
    283                  }
    284          
    285                  fftr_f(evn, log2_Nd2, direction);
    286                  fftr_f(odd, log2_Nd2, direction);
    287          
    288                  theta_pi = (direction == FFT_FORWARD) ? -M_PI : M_PI;
    289                  theta = theta_pi / Nd2;  /* - (2 * M_PI) / N */
    290                  WN.re = cos(theta);
    291                  WN.im = sin(theta);
    292          
    293                  WNk.re = 1.f;
    294                  WNk.im = 0.f;
    295                  for (k = 0; k < Nd2; k++)
    296                  {
    297                      kpNd2 = k + Nd2;
    298          
    299                      u.re = evn[k].re;
    300                      u.im = evn[k].im;
    301                      t.re = complex_mul_re(WNk.re, WNk.im, odd[k].re, odd[k].im);
    302                      t.im = complex_mul_im(WNk.re, WNk.im, odd[k].re, odd[k].im);
    303                      data[k].re = u.re + t.re;
    304                      data[k].im = u.im + t.im;
    305                      data[kpNd2].re = u.re - t.re;
    306                      data[kpNd2].im = u.im - t.im;
    307          
    308                      t.re = complex_mul_re(WNk.re, WNk.im, WN.re, WN.im);
    309                      t.im = complex_mul_im(WNk.re, WNk.im, WN.re, WN.im);
    310                      WNk = t;
    311                  }
    312              }
    313          }
    314          
    315          
    316          
    317          #else
    318          
    319          
    320          
    321          /*
    322           * A much more efficient version of the recursive FFT algorithm, where
    323           * the data and scratch buffers are commutated throughout the recursion
    324           * sequence, and index mapping is used to locate the correct values
    325           */
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void _fftrb_f(complex_f data[], complex_f scratch[], int N, double theta_pi, int stride)
    328          {
   \                     _fftrb_f: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x461F             MOV      R7,R3
    329              if (stride < N)
   \   00000008   0x42B7             CMP      R7,R6
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0xEEB0 0x8B40      VMOV.F64 D8,D0
   \   00000016   0xDA52             BGE.N    ??_fftrb_f_0
    330              {
    331                  unsigned stride2;
    332                  unsigned k;
    333                  unsigned k_e, k_o;
    334                  unsigned kd2, kpNd2;
    335                  double theta;       /* Use double for precision */
    336                  complex_d WN, WNk;  /* Use double for precision */
    337                  complex_d u, t;     /* Use double for precision */
    338          
    339                  stride2 = 2 * stride;
   \   00000018   0x007D             LSLS     R5,R7,#+1
    340          
    341                  /* Notice that the order of data and scratch buffers is swapped! */
    342                  _fftrb_f(scratch         , data         , N, theta_pi, stride2);
   \   0000001A   0x462B             MOV      R3,R5
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x4640             MOV      R0,R8
   \   00000020   0xF7FF 0xFFEE      BL       _fftrb_f
    343                  _fftrb_f(scratch + stride, data + stride, N, theta_pi, stride2);
   \   00000024   0xEB04 0x01C7      ADD      R1,R4,R7, LSL #+3
   \   00000028   0x462B             MOV      R3,R5
   \   0000002A   0xEB08 0x00C7      ADD      R0,R8,R7, LSL #+3
   \   0000002E   0xEEB0 0x0B48      VMOV.F64 D0,D8
   \   00000032   0x4632             MOV      R2,R6
   \   00000034   0xF7FF 0xFFE4      BL       _fftrb_f
    344          
    345                  theta = (stride2 * theta_pi) / N;
   \   00000038   0xEE00 0x5A10      VMOV     S0,R5
    346                  WN.re = cos(theta);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xEEB8 0x0B40      VCVT.F64.U32 D0,S0
   \   00000042   0xEE01 0x6A10      VMOV     S2,R6
   \   00000046   0xEE20 0x0B08      VMUL.F64 D0,D0,D8
   \   0000004A   0xEEB8 0x1BC1      VCVT.F64.S32 D1,S2
   \   0000004E   0xEE80 0x9B01      VDIV.F64 D9,D0,D1
   \   00000052   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000056   0x.... 0x....      BL       ?Subroutine1
    347                  WN.im = sin(theta);
    348          
    349                  WNk.re = 1.f;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000005A   0x.... 0x....      BL       ?Subroutine2
    350                  WNk.im = 0.f;
    351                  for (k = 0; k < N; k += stride2)
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000005E   0xE02C             B.N      ??CrossCallReturnLabel_1
    352                  {
    353                      k_e = k;
    354                      k_o = k + stride;
    355                      kd2 = k >> 1;
    356                      kpNd2 = (k + N) >> 1;
    357          
    358                      u.re = scratch[k_e].re;
   \                     ??_fftrb_f_1: (+1)
   \   00000060   0xEB08 0x03C0      ADD      R3,R8,R0, LSL #+3
   \   00000064   0x0841             LSRS     R1,R0,#+1
   \   00000066   0x1832             ADDS     R2,R6,R0
   \   00000068   0x0852             LSRS     R2,R2,#+1
   \   0000006A   0xED93 0x3A00      VLDR     S6,[R3, #0]
   \   0000006E   0xEEB7 0x3AC3      VCVT.F64.F32 D3,S6
    359                      u.im = scratch[k_e].im;
   \   00000072   0xED93 0x4A01      VLDR     S8,[R3, #+4]
    360                      t.re = complex_mul_re(WNk.re, WNk.im, scratch[k_o].re, scratch[k_o].im);
   \   00000076   0x183B             ADDS     R3,R7,R0
   \   00000078   0xEB08 0x0CC3      ADD      R12,R8,R3, LSL #+3
    361                      t.im = complex_mul_im(WNk.re, WNk.im, scratch[k_o].re, scratch[k_o].im);
    362          
    363                      data[kd2].re   = u.re + t.re;
    364                      data[kd2].im   = u.im + t.im;
    365                      data[kpNd2].re = u.re - t.re;
    366                      data[kpNd2].im = u.im - t.im;
    367          
    368                      t.re = complex_mul_re(WNk.re, WNk.im, WN.re, WN.im);
    369                      t.im = complex_mul_im(WNk.re, WNk.im, WN.re, WN.im);
    370                      WNk = t;
    371                  }
   \   0000007C   0x1828             ADDS     R0,R5,R0
   \   0000007E   0xEB08 0x03C3      ADD      R3,R8,R3, LSL #+3
   \   00000082   0xEEB7 0x4AC4      VCVT.F64.F32 D4,S8
   \   00000086   0xEDD3 0x6A00      VLDR     S13,[R3, #0]
   \   0000008A   0xEB04 0x03C1      ADD      R3,R4,R1, LSL #+3
   \   0000008E   0xED9C 0x6A01      VLDR     S12,[R12, #+4]
   \   00000092   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   00000096   0xEEB7 0x5AE6      VCVT.F64.F32 D5,S13
   \   0000009A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000009E   0xED83 0x6A00      VSTR     S12,[R3, #0]
   \   000000A2   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \   000000A6   0xEB04 0x01C2      ADD      R1,R4,R2, LSL #+3
   \   000000AA   0xEE33 0x3B45      VSUB.F64 D3,D3,D5
   \   000000AE   0xEEB7 0x3BC3      VCVT.F32.F64 S6,D3
   \   000000B2   0xED81 0x3A00      VSTR     S6,[R1, #0]
   \   000000B6   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000BA   0x42B0             CMP      R0,R6
   \   000000BC   0xD3D0             BCC.N    ??_fftrb_f_1
    372              }
    373          }
   \                     ??_fftrb_f_0: (+1)
   \   000000BE   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    374          
    375          
    376          

   \                                 In section .text, align 4, keep-with-next
    377          void fftrb_f(complex_f data[], unsigned log2_N, fft_dir direction, complex_f scratch[])
    378          {
   \                     fftrb_f: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4619             MOV      R1,R3
    379              unsigned N;
    380              unsigned k;
    381              double theta_pi;
    382          
    383              N = 1 << log2_N;
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0xFA03 0xF404      LSL      R4,R3,R4
    384              for (k = 0; k < N; k++)
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xE008             B.N      ??fftrb_f_0
    385                  scratch[k] = data[k];
   \                     ??fftrb_f_1: (+1)
   \   00000010   0xEB00 0x06C3      ADD      R6,R0,R3, LSL #+3
   \   00000014   0xEB01 0x05C3      ADD      R5,R1,R3, LSL #+3
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \   0000001A   0xEC96 0x0A02      VLDM     R6,{S0-S1}
   \   0000001E   0xEC85 0x0A02      VSTM     R5,{S0-S1}
   \                     ??fftrb_f_0: (+1)
   \   00000022   0x42A3             CMP      R3,R4
   \   00000024   0xD3F4             BCC.N    ??fftrb_f_1
    386          
    387              theta_pi = (direction == FFT_FORWARD) ? -M_PI : M_PI;
   \   00000026   0x2A00             CMP      R2,#+0
    388          
    389              _fftrb_f(data, scratch, N, theta_pi, 1);
   \   00000028   0x4622             MOV      R2,R4
   \   0000002A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002E   0xBF0C             ITE      EQ 
   \   00000030   0xED9F 0x....      VLDREQ.W D0,??DataTable3_1
   \   00000034   0xED9F 0x....      VLDRNE.W D0,??DataTable3_2
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0x....             B.N      _fftrb_f
    390          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x54442D11         DC32     0x54442D11,0xC01921FB
   \              0xC01921FB   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x54442D11         DC32     0x54442D11,0x401921FB
   \              0x401921FB   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x00000000         DC32     0x0,0x0
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x54442D11         DC32     0x54442D11,0xC00921FB
   \              0xC00921FB   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x54442D11         DC32     0x54442D11,0x400921FB
   \              0x400921FB   
    391          
    392          
    393          
    394          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   _fftrb_f
        40   -> __iar_Sin
        40   -> _fftrb_f
      20   ffti_copy_shuffle_f
      56   ffti_evaluate_f
        56   -> __iar_Sin
      16   ffti_f
         0   -> ffti_evaluate_f
        16   -> ffti_shuffle_f
      20   ffti_shuffle_f
      48   fftr_f
        48   -> __iar_Sin
        48   -> fftr_f
         0   -> free
        48   -> free
        48   -> malloc
      16   fftrb_f
         0   -> _fftrb_f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??DataTable2
       8  ??DataTable2_1
       8  ??DataTable3
       8  ??DataTable3_1
       8  ??DataTable3_2
      34  ?Subroutine0
      14  ?Subroutine1
      12  ?Subroutine2
      38  ?Subroutine3
      14  ?Subroutine4
     198  _fftrb_f
      60  ffti_copy_shuffle_f
     268  ffti_evaluate_f
      24  ffti_f
      76  ffti_shuffle_f
     256  fftr_f
      60  fftrb_f

 
 1 094 bytes in section .text
 
 1 094 bytes of CODE memory

Errors: none
Warnings: none
