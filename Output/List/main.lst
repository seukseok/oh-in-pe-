###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       23/Nov/2024  02:59:05
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\IAR Systems\oh-in-pe-\main.c
#    Command line =  
#        "C:\IAR Systems\oh-in-pe-\main.c" -lC "C:\IAR
#        Systems\oh-in-pe-\Output\List" -o "C:\IAR
#        Systems\oh-in-pe-\Output\Obj" --debug --endian=little --cpu=Cortex-M7
#        -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5_2\arm\INC\c\DLib_Config_Full.h" -I
#        "C:\IAR Systems\oh-in-pe-\" -I "C:\IAR Systems\oh-in-pe-\Include\" -I
#        "C:\IAR Systems\oh-in-pe-\Include\CMSIS\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Inc\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Src\" -Ohz
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM7
#    Locale       =  Korean_Korea.949
#    List file    =  C:\IAR Systems\oh-in-pe-\Output\List\main.lst
#    Object file  =  C:\IAR Systems\oh-in-pe-\Output\Obj\main.o
#
###############################################################################

C:\IAR Systems\oh-in-pe-\main.c
      1          #include "stm32f767xx.h"
      2          #include "OK-STM767.h"
      3          #include "OK-STM767_SD_card.h"
      4          #include "OK-STM767_VS1053b.h"
      5          #include "arm_math.h"
      6          
      7          // FFT 관련 상수 수정
      8          #define FFT_SIZE 256  // FFT 크기 축소하여 처리 부하 감소
      9          #define SAMPLE_FREQ 44100
     10          #define FFT_DISPLAY_HEIGHT 80
     11          #define FFT_DISPLAY_WIDTH 320
     12          #define FFT_DISPLAY_Y_START 80  // UI와 겹치지 않는 위치
     13          
     14          // 이중 버퍼링을 위한 구조체
     15          typedef struct {
     16              float32_t buffer[512];
     17              volatile uint16_t writeIdx;
     18              volatile uint16_t readIdx;
     19              volatile uint8_t isFull;
     20          } AudioBuffer;
     21          
     22          AudioBuffer audioBuffer = {0};
     23          
     24          arm_rfft_fast_instance_f32 S;
     25          float32_t FFT_Input[FFT_SIZE];  
     26          float32_t FFT_Output[FFT_SIZE];
     27          float32_t FFT_Mag[FFT_SIZE/2];
     28          
     29          // FFT 관련 전역 변수 추가
     30          #define FFT_UPDATE_PERIOD 50  // FFT 업데이트 주기 (ms)
     31          
     32          // FFT 화면 모드 플래그 추가
     33          volatile uint8_t func_mode = 0;        // 기능 선택 모드
     34          volatile uint8_t fft_display_mode = 0;  // 0: 일반 화면, 1: FFT 화면
     35          volatile uint8_t fft_update_flag = 0;   // FFT 업데이트 플래그
     36          
     37          void TFT_filename(void);                          // Display MP3 file name, number, size
     38          void TFT_volume(void);                            // Display volume
     39          void TFT_bass(void);                              // Display bass
     40          void TFT_treble(void);                            // Display treble
     41          void Check_valid_increment_file(void);            // Check if valid file for increment
     42          void Check_valid_decrement_file(void);            // Check if valid file for decrement
     43          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte);  // Display MP3 file bitrate
     44          
     45          void FFT_Init(void);                              // FFT 초기화
     46          void Process_FFT(void);                           // FFT 처리
     47          void Draw_Spectrum(float32_t* data, uint16_t size, uint16_t color);// FFT 결과 그래픽 출력
     48          void PushAudioData(uint8_t* data, uint16_t len);  // 오디오 데이터 버퍼에 저장
     49          unsigned char Icon_input(void);                   // Input touch screen icon
     50          
     51          void Display_Normal_Screen(void);                 // 일반 화면 표시 함수
     52          void Init_FFT_Screen(void);                       // FFT 화면 초기화
     53          
     54          unsigned char total_file;                         // Total file number
     55          unsigned char file_number = 0;                    // Current file number
     56          
     57          // 시스템 타이머 틱 카운트 변수
     58          static volatile uint32_t SystemTicks = 0;
     59          
     60          // SysTick 인터럽트 핸들러
     61          void SysTick_Handler(void) {
     62              static uint32_t fft_tick_count = 0;
     63              SystemTicks++;
     64              
     65              // FFT 업데이트 타이밍 제어
     66              fft_tick_count++;
     67              if(fft_tick_count >= FFT_UPDATE_PERIOD) {
     68                  fft_update_flag = 1;
     69                  fft_tick_count = 0;
     70              }
     71          }
     72          
     73          // 시스템 타이머 초기화 함수
     74          void SystemTick_Init(void) {
     75              // SysTick 설정 (1ms 간격)
     76              SysTick->LOAD = (SystemCoreClock / 1000) - 1;
     77              SysTick->VAL = 0;
     78              SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
     79                              SysTick_CTRL_TICKINT_Msk |
     80                              SysTick_CTRL_ENABLE_Msk;
     81          }
     82          
     83          // GetTick 함수 구현
     84          uint32_t GetTick(void) {
     85              return SystemTicks;
     86          }
     87          
     88          int main(void) {
     89            unsigned char i, key;
     90            unsigned char func_mode = 0;                  // Function key mode
     91            unsigned char play_flag = 0;                  // Play or stop flag
     92            unsigned short index = 512;                   // Byte index in a sector
     93            unsigned short loop = 0;                      // MP3 play loop counter
     94            unsigned int playPercentage;                  // Play percentage
     95          
     96            unsigned int MP3_start_sector[MAX_FILE];      // MP3 file start sector
     97            unsigned int MP3_start_backup[MAX_FILE];
     98            unsigned char MP3buffer[512];                 // MP3 data from SD card
     99            unsigned int MP3_end_sector;                  // MP3 file end sector
    100          
    101            unsigned short time, stereo;                  // Decode time and mono/stereo
    102            unsigned short HDAT1, HDAT0;                  // MP3 file frame header information data
    103          
    104            Initialize_MCU();                             // Initialize MCU and kit
    105            Delay_ms(50);                                 // Wait for system stabilization
    106            Initialize_LCD();                             // Initialize text LCD module
    107            Initialize_TFT_LCD();                         // Initialize TFT-LCD module
    108            Initialize_touch_screen();                    // Initialize touch screen
    109          
    110            LCD_string(0x80, " OK-STM746 V1.0 ");         // Display title
    111            LCD_string(0xC0, "   Exp20_2.c    ");
    112          
    113            TFT_string(0, 4, Green, Black, "****************************************");
    114            TFT_string(0, 6, White, Black, "                OH-IN-PE-               ");
    115            TFT_string(0, 8, Green, Black, "****************************************");
    116            TFT_string(0, 23, Cyan, Black, "           SD 카드 초기화...            ");
    117            Beep();
    118            Delay_ms(1000);
    119            TFT_clear_screen();
    120          
    121            Initialize_SD();                              // Initialize SD card
    122            Initialize_FAT32();                           // Initialize FAT32 file system
    123            Initialize_VS1053b();                         // Initialize VS1053b
    124            Delay_ms(1000);
    125          
    126            volume = 175;                                 // Initial volume = 175/250(70%)
    127            VS1053b_SetVolume(volume);
    128            Delay_ms(1);
    129            bass = 10;                                    // Initial bass = 10 and treble = 5
    130            treble = 5;
    131            VS1053b_SetBassTreble(bass, treble);
    132          
    133            TFT_clear_screen();                           // Display basic screen
    134            TFT_string(0, 0, White, Magenta, "  OH-IN-PE-  ");
    135            TFT_string(0, 3, Cyan, Black, "----------------------------------------");
    136            TFT_string(0, 5, Magenta, Black, ">>");
    137            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    138            TFT_string(0, 9, Cyan, Black, "      파일 번호 : 000/000 (   kbps)     ");
    139            TFT_string(0,11, Cyan, Black, "      파일 용량 : 0000KB  (     Hz)     ");
    140            TFT_string(0,13, Cyan, Black, "      연주 진행 : 00:00(000%)   (      )");
    141            TFT_string(0,15, Cyan, Black, "----------------------------------------");
    142            TFT_string(0,17, Green, Black, "   음량(Volume) : 000%(000/250)         ");
    143            TFT_string(0,19, Green, Black, "   저음(Bass)   :  00 (00 ~ 15)         ");
    144            TFT_string(0,21, Green, Black, "   고음(Treble) :  00 (-8 ~ +7)         ");
    145            TFT_string(0,23, Cyan, Black, "----------------------------------------");
    146            TFT_string(0,25, Cyan, Black, "   KEY1      KEY2      KEY3      KEY4   ");
    147            TFT_string(0,27, Magenta, Black, "  (PLAY)    (FUNC)     (INC)     (DEC)  ");
    148            TFT_string(27,11, Yellow, Black, "00000");
    149            TFT_string(18,13, Magenta, Black, "00");
    150            TFT_string(21,13, Magenta, Black, "00");
    151            TFT_string(33,13, Magenta, Black, " 정지 ");
    152          
    153            Rectangle(12, 196, 67, 235, Yellow);          // Display touch key outline
    154            Rectangle(92, 196, 147, 235, Yellow);
    155            Rectangle(176, 196, 231, 235, Yellow);
    156            Rectangle(256, 196, 311, 235, Yellow);
    157          
    158            TFT_volume();                                 // Display initial play value
    159            TFT_bass();
    160            TFT_treble();
    161          
    162            total_file = fatGetDirEntry(FirstDirCluster); // Get total file number
    163          
    164            for (i = 0; i < total_file; i++) {            // Get start address of all files
    165              MP3_start_sector[i] = fatClustToSect(file_start_cluster[i]);
    166                MP3_start_backup[i] = MP3_start_sector[i];
    167              }
    168          
    169            TFT_xy(22, 9);                                // Display total file number
    170            TFT_color(Yellow, Black);
    171            TFT_unsigned_decimal(total_file, 1, 3);
    172            file_number = 0;                              // Display first file name
    173            TFT_filename();
    174            Check_valid_increment_file();
    175          
    176            MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    177          
    178            while (1) {
    179              // main 루프에서 화면 업데이트 조건 수정
    180              if (((GPIOC->IDR & 0x0080) == 0x0080) && (play_flag == 1)) {
    181                  if (index == 512) {
    182                      if (MP3_end_sector == MP3_start_sector[file_number]) {
    183                          if (file_number != (total_file - 1))
    184                              file_number++;
    185                          else if (file_number == (total_file - 1))
    186                              file_number = 0;
    187          
    188                          TFT_filename();
    189                          Check_valid_increment_file();
    190          
    191                          MP3_start_sector[file_number] = MP3_start_backup[file_number];
    192                          MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    193                          VS1053b_software_reset();  // VS1053b software reset to change music file
    194                      }
    195                      index = 0;
    196                      SD_read_sector(MP3_start_sector[file_number]++, MP3buffer);
    197                  }
    198          
    199                  for (i = 0; i < 32; i++) {           // Send 32 data bytes
    200                      GPIOC->BSRR = 0x00400000;        // -MP3_DCS = 0
    201                      SPI3_write(MP3buffer[index++]);  // Write a byte of MP3 data to VS1053b
    202                      GPIOC->BSRR = 0x00000040;        // -MP3_DCS = 1
    203                  }
    204              }
    205          
    206              // 일반 화면 업데이트는 FFT 모드가 아닐 때만 수행
    207              if (!fft_display_mode) {
    208                  loop++;
    209                  if ((extension == 0x004D5033) && (loop == 250) && (play_flag == 1)) {
    210                      HDAT1 = VS1053b_SCI_Read(0x09);
    211                      HDAT0 = VS1053b_SCI_Read(0x08);
    212          
    213                      if ((HDAT1 & 0xFFE0) == 0xFFE0)
    214                          if (((HDAT1 & 0x0006) != 0x0000) && ((HDAT0 & 0x0C00) != 0x0C00))
    215                              TFT_MP3_bitrate(HDAT1, HDAT0);
    216                  } else if ((loop == 500) && (play_flag == 1)) {
    217                      loop = 0;
    218          
    219                      time = VS1053b_SCI_Read(0x04);       // Decode time
    220                      TFT_xy(18, 13);
    221                      TFT_color(Magenta, Black);
    222                      TFT_unsigned_decimal(time / 60, 1, 2);
    223                      TFT_xy(21, 13);
    224                      TFT_unsigned_decimal(time % 60, 1, 2);
    225          
    226                      playPercentage = MP3_end_sector - MP3_start_sector[file_number];
    227                      playPercentage = (unsigned int)((float)playPercentage / (float)(file_size[file_number] >> 9) * 100.);
    228                      playPercentage = 100 - playPercentage;
    229          
    230                      TFT_xy(24, 13);                      // Display play percentage
    231                      TFT_color(Yellow, Black);
    232                      if (playPercentage >= 100)
    233                          TFT_unsigned_decimal(playPercentage, 0, 3);
    234                      else if (playPercentage >= 10)
    235                          TFT_unsigned_decimal(playPercentage, 0, 2);
    236                      else
    237                          TFT_unsigned_decimal(playPercentage, 0, 1);
    238                      TFT_color(Cyan, Black);
    239                      TFT_English('%');
    240                      TFT_English(')');
    241                      TFT_English(' ');
    242                      TFT_English(' ');
    243          
    244                      stereo = VS1053b_SCI_Read(0x05);
    245                      TFT_xy(27, 11);                      // Sampling rate
    246                      TFT_color(Yellow, Black);
    247                      TFT_unsigned_decimal(stereo >> 1, 0, 5);
    248                      if ((stereo & 0x0001) == 0x0001) {   // Channel mode = stereo
    249                          TFT_string(32, 17, Cyan, Black, "(");
    250                          TFT_string(33, 17, Yellow, Black, "stereo");
    251                          TFT_string(39, 17, Cyan, Black, ")");
    252                      } else {                             // Channel mode = mono
    253                          TFT_string(32, 17, Cyan, Black, "(");
    254                          TFT_string(33, 17, Yellow, Black, " mono ");
    255                          TFT_string(39, 17, Cyan, Black, ")");
    256                      }
    257                  }
    258              }
    259          
    260              key = Key_input();                       // Key input
    261              if (key == no_key)                       // If no key input, read touch screen icon
    262                  key = Icon_input();
    263          
    264              switch (key) {
    265                case KEY1:
    266                  play_flag ^= 0x01;               // Toggle play or stop
    267                  if (play_flag == 1)
    268                    TFT_string(33, 13, Yellow, Black, "재생중");
    269                  else
    270                    TFT_string(33, 13, Magenta, Black, " 정지 ");
    271                  break;
    272          
    273                case KEY2:
    274                  if (func_mode == 0) {            // Select function
    275                    func_mode = 1;
    276                    TFT_string(0, 5, Magenta, Black, "  ");
    277                    TFT_string(0,17, Magenta, Black, ">>");
    278                  } else if (func_mode == 1) {
    279                    func_mode = 2;
    280                    TFT_string(0,17, Magenta, Black, "  ");
    281                    TFT_string(0,19, Magenta, Black, ">>");
    282                  } else if (func_mode == 2) {
    283                    func_mode = 3;
    284                    TFT_string(0,19, Magenta, Black, "  ");
    285                    TFT_string(0,21, Magenta, Black, ">>");
    286                  } else {
    287                    func_mode = 0;
    288                    TFT_string(0,21, Magenta, Black, "  ");
    289                    TFT_string(0, 5, Magenta, Black, ">>");
    290          		       }
    291          		    break;
    292          
    293                // key3 입력 시 각 기능의 값 증가, 최대값에 도달하면 최소값으로 돌아감
    294                case KEY3:
    295                    if (func_mode == 0) {            // 다음 음악 선택
    296                        if (file_number != (total_file - 1))
    297                            file_number++;
    298                        else
    299                            file_number = 0;
    300          
    301                        VS1053b_software_reset();
    302                        TFT_filename();
    303                        Check_valid_increment_file();
    304          
    305                        MP3_start_sector[file_number] = MP3_start_backup[file_number];
    306                        MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    307                        index = 512;
    308                        VS1053b_software_reset();
    309                    } else if (func_mode == 1) {     // 볼륨 증가
    310                        volume++;
    311                        if (volume > 250) {
    312                            volume = 5;  // 최소값으로 돌아감
    313                        }
    314                        VS1053b_SetVolume(volume);
    315                        TFT_volume();
    316                    } else if (func_mode == 2) {     // 베이스 증가
    317                        bass++;
    318                        if (bass > 15) {
    319                            bass = 0;  // 최소값으로 돌아감
    320                        }
    321                        VS1053b_SetBassTreble(bass, treble);
    322                        TFT_bass();
    323                    } else {                         // 트레블 증가
    324                        treble++;
    325                        if (treble > 7) {
    326                            treble = -8;  // 최소값으로 돌아감
    327                        }
    328                        VS1053b_SetBassTreble(bass, treble);
    329                        TFT_treble();
    330                    }
    331                    break;
    332          
    333                // KEY4 처리 수정
    334                case KEY4:
    335                    if (func_mode == 0) {            // 이전 음악 선택
    336                        if (file_number != 0)
    337                            file_number--;
    338                        else
    339                            file_number = total_file - 1;
    340                
    341                        TFT_filename();
    342                        Check_valid_decrement_file();
    343                
    344                        MP3_start_sector[file_number] = MP3_start_backup[file_number];
    345                        MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    346                        index = 512;
    347                        VS1053b_software_reset();
    348                    } 
    349                    else if (play_flag == 1) {  // 재생 중일 때만 FFT 처리
    350                        fft_display_mode ^= 1;  // FFT 화면 모드 토글
    351                        
    352                        if (fft_display_mode) {
    353                            // FFT 화면으로 전환
    354                            Init_FFT_Screen();
    355                            FFT_Init();  // FFT 초기화
    356                            // FFT 모드 진입 시 초기화
    357                            memset(FFT_Mag, 0, sizeof(FFT_Mag));
    358                        } else {
    359                            // 일반 화면으로 복귀
    360                            Display_Normal_Screen();
    361                        }
    362                        loop = 0;  // 일반 화면 업데이트 카운터 초기화
    363                    }
    364                    break;
    365          
    366                default:
    367                  break;
    368          	  }
    369          
    370              // main 루프의 끝부분에 FFT 처리 추가
    371              if (play_flag == 1 && fft_display_mode) {
    372                  if (fft_update_flag) {
    373                      fft_update_flag = 0;
    374                      
    375                      // FFT 처리 및 표시
    376                      PushAudioData(MP3buffer, 512);
    377                      Process_FFT();
    378                      
    379                      switch(func_mode) {
    380                          case 1:  // 전체 스펙트럼
    381                              Draw_Spectrum(FFT_Mag, FFT_SIZE/4, Magenta);
    382                              break;
    383                          case 2:  // 저주파 영역
    384                              Draw_Spectrum(FFT_Mag, FFT_SIZE/8, Blue);
    385                              break;
    386                          case 3:  // 고주파 영역
    387                              Draw_Spectrum(&FFT_Mag[FFT_SIZE/8], FFT_SIZE/8, Red);
    388                              break;
    389                      }
    390                  }
    391              }
    392            }
    393          }
    394          
    395          /* User-defined functions */
    396          
    397          void TFT_filename(void) {
    398            unsigned char file_flag;
    399            unsigned short file_KB;
    400          
    401            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    402            TFT_string(3, 5, Green, Black, "                                     ");
    403          
    404            file_flag = Get_long_filename(file_number);   // Check file name
    405          
    406            if (file_flag == 0)                           // Short file name (8.3 format)
    407              TFT_short_filename(3, 5, Green, Black);
    408            else if (file_flag == 1)                      // Long file name
    409              TFT_long_filename(3, 5, Green, Black);
    410            else if (file_flag == 2)                      // File name is longer than 195 characters
    411              TFT_string(3, 5, Red, Black, "* 파일명 길이 초과 *");
    412            else                                          // File name error
    413              TFT_string(3, 5, Red, Black, "*** 파일명 오류 ***");
    414          
    415            file_KB = file_size[file_number] / 1024;      // Calculate file size in KB
    416            if ((file_size[file_number] % 1024) != 0)
    417              file_KB++;
    418          
    419            if (file_flag != 3) {
    420              TFT_xy(18, 9);                            // File number
    421                TFT_color(Magenta, Black);
    422              TFT_unsigned_decimal(file_number + 1, 1, 3);
    423              TFT_xy(17,11);                            // File size
    424                TFT_color(Magenta, Black);
    425              TFT_unsigned_decimal(file_KB, 0, 5);
    426              }
    427          
    428            TFT_string(27, 9, Yellow, Black, "000");      // Clear bitrate
    429          
    430            TFT_xy(24, 13);                               // Display percentage = 0
    431            TFT_color(Yellow, Black);
    432            TFT_English('0');
    433            TFT_color(Cyan, Black);
    434            TFT_English('%');
    435            TFT_English(')');
    436            TFT_English(' ');
    437            TFT_English(' ');
    438          }
    439          
    440          void TFT_volume(void) {
    441            TFT_xy(18, 17);
    442            TFT_color(Magenta, Black);
    443            TFT_unsigned_decimal((unsigned int)(volume * 100.0 / 250.0 + 0.5), 0, 3);
    444            TFT_xy(23, 17);
    445            TFT_color(Yellow, Black);
    446            TFT_unsigned_decimal(volume, 1, 3);
    447          }
    448          
    449          void TFT_bass(void) {
    450            TFT_xy(19, 19);
    451            TFT_color(Magenta, Black);
    452            TFT_unsigned_decimal(bass, 1, 2);
    453          }
    454          
    455          void TFT_treble(void) {
    456            TFT_xy(19, 21);
    457            TFT_color(Magenta, Black);
    458            TFT_signed_decimal(treble, 0, 1);
    459          }
    460          
    461          void Check_valid_increment_file(void) {
    462            unsigned char file_OK_flag = 0;
    463            do {
    464              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    465                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    466                if (file_number != (total_file - 1))
    467          	    file_number++;
    468          	  else
    469          	    file_number = 0;
    470                    TFT_filename();
    471              } else {
    472                  file_OK_flag = 1;
    473              }
    474            } while (file_OK_flag == 0);
    475          }
    476          
    477          void Check_valid_decrement_file(void) {
    478            unsigned char file_OK_flag = 0;
    479            do {
    480              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    481                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    482                if (file_number != 0)
    483          	    file_number--;
    484          	  else
    485          	    file_number = total_file - 1;
    486                    TFT_filename();
    487              } else {
    488                  file_OK_flag = 1;
    489              }
    490            } while (file_OK_flag == 0);
    491          }
    492          
    493          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte) {
    494            unsigned short MPEG10_Layer1[16] = {
    495              0, 32, 64, 96, 128, 160, 192, 224,
    496              256, 288, 320, 352, 384, 416, 448, 0
    497            };
    498            unsigned short MPEG10_Layer2[16] = {
    499              0, 32, 48, 56, 64, 80, 96, 112,
    500              128, 160, 192, 224, 256, 320, 384, 0
    501            };
    502            unsigned short MPEG10_Layer3[16] = {
    503              0, 32, 40, 48, 56, 64, 80, 96,
    504              112, 128, 160, 192, 224, 256, 320, 0
    505            };
    506            unsigned short MPEG20_Layer1[16] = {
    507              0, 32, 48, 56, 64, 80, 96, 112,
    508              128, 144, 160, 176, 192, 224, 256, 0
    509            };
    510            unsigned short MPEG20_Layer2[16] = {
    511              0, 8, 16, 24, 32, 40, 48, 56,
    512              64, 80, 96, 112, 128, 144, 160, 0
    513            };
    514          
    515            if ((highbyte & 0x0018) == 0x0018) {              // MPEG-1.0
    516              switch (highbyte & 0x0006) {
    517                case 0x0002:                              // Layer-3
    518                  TFT_xy(27, 9);
    519                  TFT_color(Yellow, Black);
    520                  TFT_unsigned_decimal(MPEG10_Layer3[lowbyte >> 12], 1, 3);
    521          		        break;
    522                case 0x0004:                              // Layer-2
    523                  TFT_xy(27, 9);
    524                  TFT_color(Yellow, Black);
    525                  TFT_unsigned_decimal(MPEG10_Layer2[lowbyte >> 12], 1, 3);
    526          		        break;
    527                case 0x0006:                              // Layer-1
    528                  TFT_xy(27, 9);
    529                  TFT_color(Yellow, Black);
    530                  TFT_unsigned_decimal(MPEG10_Layer1[lowbyte >> 12], 1, 3);
    531          		        break;
    532          	}
    533            } else if ((highbyte & 0x0018) == 0x0010) {       // MPEG-2.0
    534              switch (highbyte & 0x0006) {
    535                case 0x0002:                              // Layer-3
    536                  TFT_xy(27, 9);
    537                  TFT_color(Yellow, Black);
    538                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    539          		        break;
    540                case 0x0004:                              // Layer-2
    541                  TFT_xy(27, 9);
    542                  TFT_color(Yellow, Black);
    543                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    544          		        break;
    545                case 0x0006:                              // Layer-1
    546                  TFT_xy(27, 9);
    547                  TFT_color(Yellow, Black);
    548                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    549          		        break;
    550          	}
    551            } else {                                          // MPEG-2.5
    552              switch (highbyte & 0x0006) {
    553                case 0x0002:                              // Layer-3
    554                  TFT_xy(27, 9);
    555                  TFT_color(Yellow, Black);
    556                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    557          		        break;
    558                case 0x0004:                              // Layer-2
    559                  TFT_xy(27, 9);
    560                  TFT_color(Yellow, Black);
    561                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    562          		        break;
    563                case 0x0006:                              // Layer-1
    564                  TFT_xy(27, 9);
    565                  TFT_color(Yellow, Black);
    566                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    567          		        break;
    568          	}
    569              }
    570          }
    571          
    572          unsigned char icon_flag = 0;
    573          
    574          unsigned char Icon_input(void) {
    575            unsigned char keyPressed;
    576          
    577            Touch_screen_input();                          // Input touch screen
    578          
    579            if ((icon_flag == 0) && (x_touch >= 12) && (x_touch <= 67) &&
    580              (y_touch >= 196) && (y_touch <= 235)) {
    581              keyPressed = KEY1;
    582                icon_flag = 1;
    583              // Rectangle(12, 196, 67, 235, Magenta);
    584          
    585            } else if ((icon_flag == 0) && (x_touch >= 92) && (x_touch <= 147) &&
    586                   (y_touch >= 196) && (y_touch <= 235)) {
    587              keyPressed = KEY2;
    588                icon_flag = 1;
    589              // Rectangle(92, 196, 147, 235, Magenta);
    590          
    591            } else if ((icon_flag == 0) && (x_touch >= 176) && (x_touch <= 231) &&
    592                   (y_touch >= 196) && (y_touch <= 235)) {
    593              keyPressed = KEY3;
    594                icon_flag = 1;
    595              // Rectangle(176, 196, 231, 235, Magenta);
    596          
    597            } else if ((icon_flag == 0) && (x_touch >= 256) && (x_touch <= 311) &&
    598                   (y_touch >= 196) && (y_touch <= 235)) {
    599              keyPressed = KEY4;
    600                icon_flag = 1;
    601              // Rectangle(256, 196, 311, 235, Magenta);
    602          
    603            } else if ((icon_flag == 1) && (x_touch == 0) && (y_touch == 0)) {
    604              keyPressed = no_key;
    605                icon_flag = 0;
    606              // Rectangle(12, 196, 67, 235, Yellow);
    607              // Rectangle(92, 196, 147, 235, Yellow);
    608              // Rectangle(176, 196, 231, 235, Yellow);
    609              // Rectangle(256, 196, 311, 235, Yellow);
    610                Delay_ms(50);
    611            } else {
    612              keyPressed = no_key;
    613            }
    614          
    615            return keyPressed;
    616          }
    617          
    618          // FFT 분석을 위한 함수들
    619          void FFT_Init(void) {
    620              arm_rfft_fast_init_f32(&S, FFT_SIZE);
    621          }
    622          
    623          // 오디오 데이터 버퍼링 함수
    624          void PushAudioData(uint8_t* data, uint16_t len) {
    625              for(uint16_t i = 0; i < len; i++) {
    626                  audioBuffer.buffer[audioBuffer.writeIdx] = ((float32_t)data[i] - 128.0f) / 128.0f;
    627                  audioBuffer.writeIdx = (audioBuffer.writeIdx + 1) % 512;
    628                  if(audioBuffer.writeIdx == audioBuffer.readIdx) {
    629                      audioBuffer.isFull = 1;
    630                  }
    631              }
    632          }
    633          
    634          // FFT 처리 함수 개선
    635          void Process_FFT(void) {
    636              // 1. 입력 데이터 준비
    637              for(int i = 0; i < FFT_SIZE; i++) {
    638                  // 오디오 데이터 정규화 (-1.0 ~ 1.0)
    639                  FFT_Input[i] = ((float32_t)MP3buffer[i % 512] - 128.0f) / 128.0f;
                                                    ^
Error[Pe020]: identifier "MP3buffer" is undefined
    640                  
    641                  // Hanning 윈도우 적용 (신호 품질 개선)
    642                  float32_t hann = 0.5f * (1.0f - cosf((2.0f * PI * i) / (FFT_SIZE - 1)));
    643                  FFT_Input[i] *= hann;
    644              }
    645          
    646              // 2. FFT 실행
    647              arm_rfft_fast_f32(&S, FFT_Input, FFT_Output, 0);
    648          
    649              // 3. magnitude 계산 및 로그 스케일 변환
    650              for(int i = 0; i < FFT_SIZE/2; i++) {
    651                  float32_t real = FFT_Output[2*i];
    652                  float32_t imag = FFT_Output[2*i + 1];
    653                  FFT_Mag[i] = sqrtf(real*real + imag*imag);
    654                  // 로그 스케일 변환 (dB)
    655                  FFT_Mag[i] = 20 * log10f(FFT_Mag[i] + 1e-6f);
    656              }
    657          }
    658          
    659          // Draw_Spectrum 함수 수정
    660          void Draw_Spectrum(float32_t* data, uint16_t size, uint16_t color) {
    661              static uint32_t lastDrawTime = 0;
    662              uint32_t currentTime = GetTick();
    663              
    664              // 화면 업데이트 제어 (60fps)
    665              if(currentTime - lastDrawTime < 16) return;
    666              lastDrawTime = currentTime;
    667          
    668              // 1. 표시 영역 정의
    669              const uint16_t GRAPH_X = 10;
    670              const uint16_t GRAPH_Y = 80;
    671              const uint16_t GRAPH_WIDTH = 300;
    672              const uint16_t GRAPH_HEIGHT = 120;
    673              
    674              // 2. 배경 지우기
    675              Rectangle(GRAPH_X, GRAPH_Y, GRAPH_X + GRAPH_WIDTH, GRAPH_Y + GRAPH_HEIGHT, Black);
    676          
    677              // 3. 그리드 그리기
    678              for(int i = 0; i <= 10; i++) {
    679                  Line(GRAPH_X, GRAPH_Y + i * (GRAPH_HEIGHT/10),
    680                       GRAPH_X + GRAPH_WIDTH, GRAPH_Y + i * (GRAPH_HEIGHT/10),
    681                       DarkGrey);
    682              }
    683          
    684              // 4. 데이터 정규화 및 그래프 그리기
    685              float32_t maxDb = 100.0f;  // 최대 dB 값
    686              float32_t minDb = 0.0f;    // 최소 dB 값
    687              uint16_t barWidth = (GRAPH_WIDTH / size);
    688              
    689              for(int i = 0; i < size; i++) {
    690                  // 높이 계산 (dB 스케일)
    691                  float32_t normalizedHeight = (data[i] - minDb) / (maxDb - minDb);
    692                  if(normalizedHeight < 0.0f) normalizedHeight = 0.0f;
    693                  if(normalizedHeight > 1.0f) normalizedHeight = 1.0f;
    694                  
    695                  uint16_t barHeight = (uint16_t)(normalizedHeight * GRAPH_HEIGHT);
    696                  
    697                  // 막대 그리기
    698                  if(barHeight > 0) {
    699                      Rectangle(GRAPH_X + i * barWidth,
    700                               GRAPH_Y + GRAPH_HEIGHT - barHeight,
    701                               GRAPH_X + (i + 1) * barWidth - 1,
    702                               GRAPH_Y + GRAPH_HEIGHT,
    703                               color);
    704                      
    705                      // 피크 표시
    706                      Line(GRAPH_X + i * barWidth,
    707                           GRAPH_Y + GRAPH_HEIGHT - barHeight,
    708                           GRAPH_X + (i + 1) * barWidth - 1,
    709                           GRAPH_Y + GRAPH_HEIGHT - barHeight,
    710                           White);
    711                  }
    712              }
    713          
    714              // 5. 디버깅 정보 표시
    715              char debug[32];
    716              sprintf(debug, "FPS: %d", (int)(1000.0f/(currentTime - lastDrawTime)));
                     ^
Warning[Pe223]: function "sprintf" declared implicitly
    717              TFT_string(GRAPH_X, GRAPH_Y - 20, White, Black, debug);
                                                                     ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "U08 *"
    718          }
    719          
    720          // 일반 화면 표시 함수
    721          void Display_Normal_Screen(void) {
    722              TFT_clear_screen();
    723              TFT_string(0, 0, White, Magenta, "  OH-IN-PE-  ");
    724              TFT_string(0, 3, Cyan, Black, "----------------------------------------");
    725              TFT_string(0, 5, Magenta, Black, ">>");
    726              TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    727              TFT_string(0, 9, Cyan, Black, "      파일 번호 : 000/000 (   kbps)     ");
    728              TFT_string(0,11, Cyan, Black, "      파?? 용량 : 0000KB  (     Hz)     ");
    729              TFT_string(0,13, Cyan, Black, "      연주 진행 : 00:00(000%)   (      )");
    730              TFT_string(0,15, Cyan, Black, "----------------------------------------");
    731              TFT_string(0,17, Green, Black, "   음량(Volume) : 000%(000/250)         ");
    732              TFT_string(0,19, Green, Black, "   저음(Bass)   :  00 (00 ~ 15)         ");
    733              TFT_string(0,21, Green, Black, "   고음(Treble) :  00 (-8 ~ +7)         ");
    734              TFT_string(0,23, Cyan, Black, "----------------------------------------");
    735              TFT_string(0,25, Cyan, Black, "   KEY1      KEY2      KEY3      KEY4   ");
    736              TFT_string(0,27, Magenta, Black, "  (PLAY)    (FUNC)     (INC)     (DEC)  ");
    737              
    738              // 현재 상태 업데이트
    739              TFT_filename();
    740              TFT_volume();
    741              TFT_bass();
    742              TFT_treble();
    743          }
    744          
    745          // FFT 화면 초기화 함수 수정
    746          void Init_FFT_Screen(void) {
    747              TFT_clear_screen();
    748              
    749              // 상단 타이틀
    750              TFT_string(0, 0, White, Magenta, "  FFT Analyzer  ");
    751              TFT_string(0, 2, Cyan, Black, "----------------------------------------");
    752              
    753              // FFT 모드 표시
    754              switch(func_mode) {
    755                  case 1:
    756                      TFT_string(0, 4, Yellow, Black, "Mode: Full Spectrum Analysis");
    757                      break;
    758                  case 2:
    759                      TFT_string(0, 4, Blue, Black, "Mode: Low Frequency Analysis");
    760                      break;
    761                  case 3:
    762                      TFT_string(0, 4, Red, Black, "Mode: High Frequency Analysis");
    763                      break;
    764              }
    765              
    766              // FFT 표시 영역 초기화
    767              Rectangle(0, FFT_DISPLAY_Y_START, 
    768                       FFT_DISPLAY_WIDTH, 
    769                       FFT_DISPLAY_Y_START + FFT_DISPLAY_HEIGHT, 
    770                       Black);
    771          
    772              // 하단 안내 메시지
    773              TFT_string(0, 27, White, Black, "Press KEY4 to return to normal mode");
    774          }

Errors: 1
Warnings: 2
