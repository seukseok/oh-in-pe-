###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       22/Nov/2024  22:41:33
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\IAR Systems\oh-in-pe-\main.c
#    Command line =  
#        "C:\IAR Systems\oh-in-pe-\main.c" -lC "C:\IAR
#        Systems\oh-in-pe-\Output\List" -o "C:\IAR
#        Systems\oh-in-pe-\Output\Obj" --debug --endian=little --cpu=Cortex-M7
#        -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5_2\arm\INC\c\DLib_Config_Full.h" -I
#        "C:\IAR Systems\oh-in-pe-\" -I "C:\IAR Systems\oh-in-pe-\Include\" -I
#        "C:\IAR Systems\oh-in-pe-\Include\CMSIS\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Inc\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Src\" -Ohz
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM7
#    Locale       =  Korean_Korea.949
#    List file    =  C:\IAR Systems\oh-in-pe-\Output\List\main.lst
#    Object file  =  C:\IAR Systems\oh-in-pe-\Output\Obj\main.o
#
###############################################################################

C:\IAR Systems\oh-in-pe-\main.c
      1          #include "stm32f767xx.h"
      2          #include "OK-STM767.h"
      3          #include "OK-STM767_SD_card.h"
      4          #include "OK-STM767_VS1053b.h"
      5          #include "arm_math.h"
      6          
      7          void TFT_filename(void);                          // Display MP3 file name, number, size
      8          void TFT_volume(void);                            // Display volume
      9          void TFT_bass(void);                              // Display bass
     10          void TFT_treble(void);                            // Display treble
     11          void Check_valid_increment_file(void);            // Check if valid file for increment
     12          void Check_valid_decrement_file(void);            // Check if valid file for decrement
     13          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte);  // Display MP3 file bitrate
     14          unsigned char Icon_input(void);                   // Input touch screen icon
     15          
     16          unsigned char total_file;                         // Total file number
     17          unsigned char file_number = 0;                    // Current file number
     18          
     19          int main(void) {
     20            unsigned char i, key;
     21            unsigned char func_mode = 0;                  // Function key mode
     22            unsigned char play_flag = 0;                  // Play or stop flag
     23            unsigned short index = 512;                   // Byte index in a sector
     24            unsigned short loop = 0;                      // MP3 play loop counter
     25            unsigned int playPercentage;                  // Play percentage
     26          
     27            unsigned int MP3_start_sector[MAX_FILE];      // MP3 file start sector
     28            unsigned int MP3_start_backup[MAX_FILE];
     29            unsigned char MP3buffer[512];                 // MP3 data from SD card
     30            unsigned int MP3_end_sector;                  // MP3 file end sector
     31          
     32            unsigned short time, stereo;                  // Decode time and mono/stereo
     33            unsigned short HDAT1, HDAT0;                  // MP3 file frame header information data
     34          
     35            Initialize_MCU();                             // Initialize MCU and kit
     36            Delay_ms(50);                                 // Wait for system stabilization
     37            Initialize_LCD();                             // Initialize text LCD module
     38            Initialize_TFT_LCD();                         // Initialize TFT-LCD module
     39            Initialize_touch_screen();                    // Initialize touch screen
     40          
     41            LCD_string(0x80, " OK-STM746 V1.0 ");         // Display title
     42            LCD_string(0xC0, "   Exp20_2.c    ");
     43          
     44            TFT_string(0, 4, Green, Black, "****************************************");
     45            TFT_string(0, 6, White, Black, "  OK-STM767 키트를 이용한 MP3 플레이어  ");
     46            TFT_string(0, 8, Green, Black, "****************************************");
     47            TFT_string(0, 23, Cyan, Black, "           SD 카드 초기화...            ");
     48            Beep();
     49            Delay_ms(1000);
     50            TFT_clear_screen();
     51          
     52            Initialize_SD();                              // Initialize SD card
     53            Initialize_FAT32();                           // Initialize FAT32 file system
     54            Initialize_VS1053b();                         // Initialize VS1053b
     55            Delay_ms(1000);
     56          
     57            volume = 175;                                 // Initial volume = 175/250(70%)
     58            VS1053b_SetVolume(volume);
     59            Delay_ms(1);
     60            bass = 10;                                    // Initial bass = 10 and treble = 5
     61            treble = 5;
     62            VS1053b_SetBassTreble(bass, treble);
     63          
     64            TFT_clear_screen();                           // Display basic screen
     65            TFT_string(0, 0, White, Magenta, "  OH-IN-PE-  ");
     66            TFT_string(0, 3, Cyan, Black, "----------------------------------------");
     67            TFT_string(0, 5, Magenta, Black, ">>");
     68            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
     69            TFT_string(0, 9, Cyan, Black, "      파일 번호 : 000/000 (   kbps)     ");
     70            TFT_string(0,11, Cyan, Black, "      파일 용량 : 0000KB  (     Hz)     ");
     71            TFT_string(0,13, Cyan, Black, "      연주 진행 : 00:00(000%)   (      )");
     72            TFT_string(0,15, Cyan, Black, "----------------------------------------");
     73            TFT_string(0,17, Green, Black, "   음량(Volume) : 000%(000/250)         ");
     74            TFT_string(0,19, Green, Black, "   저음(Bass)   :  00 (00 ~ 15)         ");
     75            TFT_string(0,21, Green, Black, "   고음(Treble) :  00 (-8 ~ +7)         ");
     76            TFT_string(0,23, Cyan, Black, "----------------------------------------");
     77            TFT_string(0,25, Cyan, Black, "   KEY1      KEY2      KEY3      KEY4   ");
     78            TFT_string(0,27, Magenta, Black, "  (PLAY)    (FUNC)     (INC)     (DEC)  ");
     79            TFT_string(27,11, Yellow, Black, "00000");
     80            TFT_string(18,13, Magenta, Black, "00");
     81            TFT_string(21,13, Magenta, Black, "00");
     82            TFT_string(33,13, Magenta, Black, " 정지 ");
     83          
     84            Rectangle(12, 196, 67, 235, Yellow);          // Display touch key outline
     85            Rectangle(92, 196, 147, 235, Yellow);
     86            Rectangle(176, 196, 231, 235, Yellow);
     87            Rectangle(256, 196, 311, 235, Yellow);
     88          
     89            TFT_volume();                                 // Display initial play value
     90            TFT_bass();
     91            TFT_treble();
     92          
     93            total_file = fatGetDirEntry(FirstDirCluster); // Get total file number
     94          
     95            for (i = 0; i < total_file; i++) {            // Get start address of all files
     96              MP3_start_sector[i] = fatClustToSect(file_start_cluster[i]);
     97                MP3_start_backup[i] = MP3_start_sector[i];
     98              }
     99          
    100            TFT_xy(22, 9);                                // Display total file number
    101            TFT_color(Yellow, Black);
    102            TFT_unsigned_decimal(total_file, 1, 3);
    103            file_number = 0;                              // Display first file name
    104            TFT_filename();
    105            Check_valid_increment_file();
    106          
    107            MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    108          
    109            while (1) {
    110              if (((GPIOC->IDR & 0x0080) == 0x0080) && (play_flag == 1)) {
    111                if (index == 512) {
    112                  if (MP3_end_sector == MP3_start_sector[file_number]) {
    113                    if (file_number != (total_file - 1))
    114          	  	    file_number++;
    115                    else if (file_number == (total_file - 1))
    116          	  	    file_number = 0;
    117          
    118          		  TFT_filename();
    119          		  Check_valid_increment_file();
    120          
    121          		  MP3_start_sector[file_number] = MP3_start_backup[file_number];
    122          		  MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    123                    VS1053b_software_reset();  // VS1053b software reset to change music file
    124          		}
    125          	      index = 0;
    126                        SD_read_sector(MP3_start_sector[file_number]++, MP3buffer);
    127                      }
    128          
    129                for (i = 0; i < 32; i++) {           // Send 32 data bytes
    130                  GPIOC->BSRR = 0x00400000;        // -MP3_DCS = 0
    131                  SPI3_write(MP3buffer[index++]);  // Write a byte of MP3 data to VS1053b
    132                  GPIOC->BSRR = 0x00000040;        // -MP3_DCS = 1
    133          	    }
    134          	}
    135          
    136              loop++;                                  // Display MP3 file bitrate or play percentage
    137              if ((extension == 0x004D5033) && (loop == 250) && (play_flag == 1)) {
    138                HDAT1 = VS1053b_SCI_Read(0x09);
    139          	  HDAT0 = VS1053b_SCI_Read(0x08);
    140          
    141                if ((HDAT1 & 0xFFE0) == 0xFFE0)
    142                  if (((HDAT1 & 0x0006) != 0x0000) && ((HDAT0 & 0x0C00) != 0x0C00))
    143                    TFT_MP3_bitrate(HDAT1, HDAT0);
    144              } else if ((loop == 500) && (play_flag == 1)) {
    145                loop = 0;
    146          
    147                time = VS1053b_SCI_Read(0x04);       // Decode time
    148                TFT_xy(18, 13);
    149            	  TFT_color(Magenta, Black);
    150                TFT_unsigned_decimal(time / 60, 1, 2);
    151                TFT_xy(21, 13);
    152                TFT_unsigned_decimal(time % 60, 1, 2);
    153          
    154              playPercentage = MP3_end_sector - MP3_start_sector[file_number];
    155                playPercentage = (unsigned int)((float)playPercentage / (float)(file_size[file_number] >> 9) * 100.);
    156              playPercentage = 100 - playPercentage;
    157          
    158                TFT_xy(24, 13);                      // Display play percentage
    159                TFT_color(Yellow, Black);
    160                if (playPercentage >= 100)
    161                  TFT_unsigned_decimal(playPercentage, 0, 3);
    162                else if (playPercentage >= 10)
    163                  TFT_unsigned_decimal(playPercentage, 0, 2);
    164                else
    165                  TFT_unsigned_decimal(playPercentage, 0, 1);
    166                TFT_color(Cyan, Black);
    167                    TFT_English('%');
    168          	  TFT_English(')');
    169                    TFT_English(' ');
    170                    TFT_English(' ');
    171          
    172          	  stereo = VS1053b_SCI_Read(0x05);
    173                TFT_xy(27, 11);                      // Sampling rate
    174            	  TFT_color(Yellow, Black);
    175                TFT_unsigned_decimal(stereo >> 1, 0, 5);
    176                if ((stereo & 0x0001) == 0x0001) {   // Channel mode = stereo
    177                  TFT_string(32, 17, Cyan, Black, "(");
    178                  TFT_string(33, 17, Yellow, Black, "stereo");
    179                  TFT_string(39, 17, Cyan, Black, ")");
    180                } else {                             // Channel mode = mono
    181                  TFT_string(32, 17, Cyan, Black, "(");
    182                  TFT_string(33, 17, Yellow, Black, " mono ");
    183                  TFT_string(39, 17, Cyan, Black, ")");
    184          	    }
    185          	}
    186          
    187              key = Key_input();                       // Key input
    188              if (key == no_key)                       // If no key input, read touch screen icon
    189                  key = Icon_input();
    190          
    191              switch (key) {
    192                case KEY1:
    193                  play_flag ^= 0x01;               // Toggle play or stop
    194                  if (play_flag == 1)
    195                    TFT_string(33, 13, Yellow, Black, "연주중");
    196                  else
    197                    TFT_string(33, 13, Magenta, Black, " 정지 ");
    198                               break;
    199          
    200                case KEY2:
    201                  if (func_mode == 0) {            // Select function
    202                    func_mode = 1;
    203                    TFT_string(0, 5, Magenta, Black, "  ");
    204                    TFT_string(0,17, Magenta, Black, ">>");
    205                  } else if (func_mode == 1) {
    206                    func_mode = 2;
    207                    TFT_string(0,17, Magenta, Black, "  ");
    208                    TFT_string(0,19, Magenta, Black, ">>");
    209                  } else if (func_mode == 2) {
    210                    func_mode = 3;
    211                    TFT_string(0,19, Magenta, Black, "  ");
    212                    TFT_string(0,21, Magenta, Black, ">>");
    213                  } else {
    214                    func_mode = 0;
    215                    TFT_string(0,21, Magenta, Black, "  ");
    216                    TFT_string(0, 5, Magenta, Black, ">>");
    217          		       }
    218          		     break;
    219          
    220                // key3 입력 시 각 기능의 값 증가, 최대값에 도달하면 최소값으로 돌아감
    221                case KEY3:
    222                    if (func_mode == 0) {            // 다음 음악 선택
    223                        if (file_number != (total_file - 1))
    224                            file_number++;
    225                        else
    226                            file_number = 0;
    227          
    228                        VS1053b_software_reset();
    229                        TFT_filename();
    230                        Check_valid_increment_file();
    231          
    232                        MP3_start_sector[file_number] = MP3_start_backup[file_number];
    233                        MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    234                        index = 512;
    235                        VS1053b_software_reset();
    236                    } else if (func_mode == 1) {     // 볼륨 증가
    237                        volume++;
    238                        if (volume > 250) {
    239                            volume = 5;  // 최소값으로 돌아감
    240                        }
    241                        VS1053b_SetVolume(volume);
    242                        TFT_volume();
    243                    } else if (func_mode == 2) {     // 베이스 증가
    244                        bass++;
    245                        if (bass > 15) {
    246                            bass = 0;  // 최소값으로 돌아감
    247                        }
    248                        VS1053b_SetBassTreble(bass, treble);
    249                        TFT_bass();
    250                    } else {                         // 트레블 증가
    251                        treble++;
    252                        if (treble > 7) {
    253                            treble = -8;  // 최소값으로 돌아감
    254                        }
    255                        VS1053b_SetBassTreble(bass, treble);
    256                        TFT_treble();
    257                    }
    258                    break;
    259          
    260                // key4에 대한 기존 처리는 제거되었습니다.
    261                case KEY4:
    262                    if (func_mode == 0) {            // 이전 음악 선택
    263                        if (file_number != 0)
    264                            file_number--;
    265                        else
    266                            file_number = total_file - 1;
    267          
    268                        TFT_filename();
    269                        Check_valid_decrement_file();
    270          
    271                        MP3_start_sector[file_number] = MP3_start_backup[file_number];
    272                        MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    273                        index = 512;
    274                        VS1053b_software_reset();
    275                    } else {
    276                        // key4에 대한 다른 기능을 위해 기존 처리를 제거하였습니다.
    277                    }
    278                    break;
    279          
    280                default:
    281                  break;
    282          	  }
    283            }
    284          }
    285          
    286          /* User-defined functions */
    287          
    288          void TFT_filename(void) {
    289            unsigned char file_flag;
    290            unsigned short file_KB;
    291          
    292            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    293            TFT_string(3, 5, Green, Black, "                                     ");
    294          
    295            file_flag = Get_long_filename(file_number);   // Check file name
    296          
    297            if (file_flag == 0)                           // Short file name (8.3 format)
    298              TFT_short_filename(3, 5, Green, Black);
    299            else if (file_flag == 1)                      // Long file name
    300              TFT_long_filename(3, 5, Green, Black);
    301            else if (file_flag == 2)                      // File name is longer than 195 characters
    302              TFT_string(3, 5, Red, Black, "* 파일명 길이 초과 *");
    303            else                                          // File name error
    304              TFT_string(3, 5, Red, Black, "*** 파일명 오류 ***");
    305          
    306            file_KB = file_size[file_number] / 1024;      // Calculate file size in KB
    307            if ((file_size[file_number] % 1024) != 0)
    308              file_KB++;
    309          
    310            if (file_flag != 3) {
    311              TFT_xy(18, 9);                            // File number
    312                TFT_color(Magenta, Black);
    313              TFT_unsigned_decimal(file_number + 1, 1, 3);
    314              TFT_xy(17,11);                            // File size
    315                TFT_color(Magenta, Black);
    316              TFT_unsigned_decimal(file_KB, 0, 5);
    317              }
    318          
    319            TFT_string(27, 9, Yellow, Black, "000");      // Clear bitrate
    320          
    321            TFT_xy(24, 13);                               // Display percentage = 0
    322            TFT_color(Yellow, Black);
    323            TFT_English('0');
    324            TFT_color(Cyan, Black);
    325            TFT_English('%');
    326            TFT_English(')');
    327            TFT_English(' ');
    328            TFT_English(' ');
    329          }
    330          
    331          void TFT_volume(void) {
    332            TFT_xy(18, 17);
    333            TFT_color(Magenta, Black);
    334            TFT_unsigned_decimal((unsigned int)(volume * 100.0 / 250.0 + 0.5), 0, 3);
    335            TFT_xy(23, 17);
    336            TFT_color(Yellow, Black);
    337            TFT_unsigned_decimal(volume, 1, 3);
    338          }
    339          
    340          void TFT_bass(void) {
    341            TFT_xy(19, 19);
    342            TFT_color(Magenta, Black);
    343            TFT_unsigned_decimal(bass, 1, 2);
    344          }
    345          
    346          void TFT_treble(void) {
    347            TFT_xy(19, 21);
    348            TFT_color(Magenta, Black);
    349            TFT_signed_decimal(treble, 0, 1);
    350          }
    351          
    352          void Check_valid_increment_file(void) {
    353            unsigned char file_OK_flag = 0;
    354            do {
    355              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    356                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    357                if (file_number != (total_file - 1))
    358          	    file_number++;
    359          	  else
    360          	    file_number = 0;
    361                    TFT_filename();
    362              } else {
    363                  file_OK_flag = 1;
    364              }
    365            } while (file_OK_flag == 0);
    366          }
    367          
    368          void Check_valid_decrement_file(void) {
    369            unsigned char file_OK_flag = 0;
    370            do {
    371              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    372                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    373                if (file_number != 0)
    374          	    file_number--;
    375          	  else
    376          	    file_number = total_file - 1;
    377                    TFT_filename();
    378              } else {
    379                  file_OK_flag = 1;
    380              }
    381            } while (file_OK_flag == 0);
    382          }
    383          
    384          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte) {
    385            unsigned short MPEG10_Layer1[16] = {
    386              0, 32, 64, 96, 128, 160, 192, 224,
    387              256, 288, 320, 352, 384, 416, 448, 0
    388            };
    389            unsigned short MPEG10_Layer2[16] = {
    390              0, 32, 48, 56, 64, 80, 96, 112,
    391              128, 160, 192, 224, 256, 320, 384, 0
    392            };
    393            unsigned short MPEG10_Layer3[16] = {
    394              0, 32, 40, 48, 56, 64, 80, 96,
    395              112, 128, 160, 192, 224, 256, 320, 0
    396            };
    397            unsigned short MPEG20_Layer1[16] = {
    398              0, 32, 48, 56, 64, 80, 96, 112,
    399              128, 144, 160, 176, 192, 224, 256, 0
    400            };
    401            unsigned short MPEG20_Layer2[16] = {
    402              0, 8, 16, 24, 32, 40, 48, 56,
    403              64, 80, 96, 112, 128, 144, 160, 0
    404            };
    405          
    406            if ((highbyte & 0x0018) == 0x0018) {              // MPEG-1.0
    407              switch (highbyte & 0x0006) {
    408                case 0x0002:                              // Layer-3
    409                  TFT_xy(27, 9);
    410                  TFT_color(Yellow, Black);
    411                  TFT_unsigned_decimal(MPEG10_Layer3[lowbyte >> 12], 1, 3);
    412          		        break;
    413                case 0x0004:                              // Layer-2
    414                  TFT_xy(27, 9);
    415                  TFT_color(Yellow, Black);
    416                  TFT_unsigned_decimal(MPEG10_Layer2[lowbyte >> 12], 1, 3);
    417          		        break;
    418                case 0x0006:                              // Layer-1
    419                  TFT_xy(27, 9);
    420                  TFT_color(Yellow, Black);
    421                  TFT_unsigned_decimal(MPEG10_Layer1[lowbyte >> 12], 1, 3);
    422          		        break;
    423          	}
    424            } else if ((highbyte & 0x0018) == 0x0010) {       // MPEG-2.0
    425              switch (highbyte & 0x0006) {
    426                case 0x0002:                              // Layer-3
    427                  TFT_xy(27, 9);
    428                  TFT_color(Yellow, Black);
    429                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    430          		        break;
    431                case 0x0004:                              // Layer-2
    432                  TFT_xy(27, 9);
    433                  TFT_color(Yellow, Black);
    434                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    435          		        break;
    436                case 0x0006:                              // Layer-1
    437                  TFT_xy(27, 9);
    438                  TFT_color(Yellow, Black);
    439                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    440          		        break;
    441          	}
    442            } else {                                          // MPEG-2.5
    443              switch (highbyte & 0x0006) {
    444                case 0x0002:                              // Layer-3
    445                  TFT_xy(27, 9);
    446                  TFT_color(Yellow, Black);
    447                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    448          		        break;
    449                case 0x0004:                              // Layer-2
    450                  TFT_xy(27, 9);
    451                  TFT_color(Yellow, Black);
    452                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    453          		        break;
    454                case 0x0006:                              // Layer-1
    455                  TFT_xy(27, 9);
    456                  TFT_color(Yellow, Black);
    457                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    458          		        break;
    459          	}
    460              }
    461          }
    462          
    463          unsigned char icon_flag = 0;
    464          
    465          unsigned char Icon_input(void) {
    466            unsigned char keyPressed;
    467          
    468            Touch_screen_input();                          // Input touch screen
    469          
    470            if ((icon_flag == 0) && (x_touch >= 12) && (x_touch <= 67) &&
    471              (y_touch >= 196) && (y_touch <= 235)) {
    472              keyPressed = KEY1;
    473                icon_flag = 1;
    474              Rectangle(12, 196, 67, 235, Magenta);
    475                Beep();
    476            } else if ((icon_flag == 0) && (x_touch >= 92) && (x_touch <= 147) &&
    477                   (y_touch >= 196) && (y_touch <= 235)) {
    478              keyPressed = KEY2;
    479                icon_flag = 1;
    480              Rectangle(92, 196, 147, 235, Magenta);
    481                Beep();
    482            } else if ((icon_flag == 0) && (x_touch >= 176) && (x_touch <= 231) &&
    483                   (y_touch >= 196) && (y_touch <= 235)) {
    484              keyPressed = KEY3;
    485                icon_flag = 1;
    486              Rectangle(176, 196, 231, 235, Magenta);
    487                Beep();
    488            } else if ((icon_flag == 0) && (x_touch >= 256) && (x_touch <= 311) &&
    489                   (y_touch >= 196) && (y_touch <= 235)) {
    490              keyPressed = KEY4;
    491                icon_flag = 1;
    492              Rectangle(256, 196, 311, 235, Magenta);
    493                Beep();
    494            } else if ((icon_flag == 1) && (x_touch == 0) && (y_touch == 0)) {
    495              keyPressed = no_key;
    496                icon_flag = 0;
    497              Rectangle(12, 196, 67, 235, Yellow);
    498              Rectangle(92, 196, 147, 235, Yellow);
    499              Rectangle(176, 196, 231, 235, Yellow);
    500              Rectangle(256, 196, 311, 235, Yellow);
    501                Delay_ms(50);
    502            } else {
    503              keyPressed = no_key;
    504            }
    505          
    506            return keyPressed;
    507          }
    508          
    509          void Analyze_Audio_Display_Graph(void) {
    510            #define FFT_SIZE 1024
    511          
    512            /* FFT input and output buffers */
    513            float32_t inputSignal[FFT_SIZE];
    514            float32_t fftOutput[FFT_SIZE];
    515            arm_rfft_fast_instance_f32 S;
    516          
    517            /* Initialize FFT instance */
    518            arm_rfft_fast_init_f32(&S, FFT_SIZE);
    519          
    520            /* Read audio samples */
    521            for (uint16_t i = 0; i < FFT_SIZE; i++) {
    522              inputSignal[i] = Get_Audio_Sample();
                                      ^
Warning[Pe223]: function "Get_Audio_Sample" declared implicitly
    523            }
    524          
    525            /* Perform FFT */
    526            arm_rfft_fast_f32(&S, inputSignal, fftOutput, 0);
    527          
    528            /* Compute magnitude */
    529            float32_t fftMagnitude[FFT_SIZE / 2];
    530            for (uint16_t i = 0; i < FFT_SIZE / 2; i++) {
    531              fftMagnitude[i] = sqrtf(fftOutput[2 * i] * fftOutput[2 * i] + fftOutput[2 * i + 1] * fftOutput[2 * i + 1]);
    532            }
    533          
    534            /* Display FFT result on TFT-LCD */
    535            Display_FFT_Graph(fftMagnitude, FFT_SIZE / 2);
                   ^
Warning[Pe223]: function "Display_FFT_Graph" declared implicitly
    536          }
    537          
    538          float32_t Get_Audio_Sample(void) {
                           ^
Error[Pe159]: declaration is incompatible with previous "Get_Audio_Sample"
          (declared at line 522)
    539            /* Replace with actual audio sample retrieval code */
    540            return 0.0f;
    541          }
    542          
    543          void Display_FFT_Graph(float32_t *data, uint16_t length) {
                      ^
Error[Pe159]: declaration is incompatible with previous "Display_FFT_Graph"
          (declared at line 535)
    544            uint16_t maxHeight = 100;  // Adjust based on display resolution
    545            float32_t maxValue = 0.0f;
    546          
    547            /* Find maximum value for scaling */
    548            for (uint16_t i = 0; i < length; i++) {
    549              if (data[i] > maxValue) {
    550                maxValue = data[i];
    551              }
    552            }
    553          
    554            /* Avoid division by zero */
    555            if (maxValue == 0.0f) {
    556              maxValue = 1.0f;
    557            }
    558          
    559            /* Draw FFT graph */
    560            for (uint16_t i = 0; i < length; i++) {
    561              uint16_t x = i * (320 / length);  // Adjust for display width
    562              uint16_t barHeight = (uint16_t)((data[i] / maxValue) * maxHeight);
    563              Draw_Bar(x, maxHeight - barHeight, barHeight);
                     ^
Warning[Pe223]: function "Draw_Bar" declared implicitly
    564            }
    565          }
    566          
    567          void Draw_Bar(uint16_t x, uint16_t y, uint16_t height) {
                      ^
Error[Pe159]: declaration is incompatible with previous "Draw_Bar" (declared at
          line 563)
    568            /* Replace with actual drawing code */
    569            /* Example: Draw a vertical line from (x, y) with the specified height */
    570          }

Errors: 3
Warnings: 3
