###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       24/Nov/2024  04:51:02
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\IAR Systems\oh-in-pe-\main.c
#    Command line =  
#        "C:\IAR Systems\oh-in-pe-\main.c" -lC "C:\IAR
#        Systems\oh-in-pe-\Output\List" -o "C:\IAR
#        Systems\oh-in-pe-\Output\Obj" --debug --endian=little --cpu=Cortex-M7
#        -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5_2\arm\INC\c\DLib_Config_Full.h" -I
#        "C:\IAR Systems\oh-in-pe-\" -I "C:\IAR Systems\oh-in-pe-\Include\" -I
#        "C:\IAR Systems\oh-in-pe-\Include\CMSIS\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Inc\" -I "C:\IAR
#        Systems\oh-in-pe-\Include\STM32F7xx_HAL_Driver\Src\" -Ohz
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM7
#    Locale       =  Korean_Korea.949
#    List file    =  C:\IAR Systems\oh-in-pe-\Output\List\main.lst
#    Object file  =  C:\IAR Systems\oh-in-pe-\Output\Obj\main.o
#
###############################################################################

C:\IAR Systems\oh-in-pe-\main.c
      1          #include "stm32f767xx.h"
      2          #include "OK-STM767.h"
      3          #include "OK-STM767_SD_card.h"
      4          #include "OK-STM767_VS1053b.h"
      5          #include "arm_math.h"
      6          #include <stdio.h>
      7          #include <string.h>
      8          #include <math.h>
      9          
     10          // Visualizer 관련 상수
     11          #define VIS_BAR_COUNT    16    // 시각화 막대 개수
     12          #define VIS_BAR_WIDTH    10    // 막대 너비
     13          #define VIS_BAR_SPACING   5    // 막대 간격
     14          #define VIS_START_X      40    // 시작 X 좌표
     15          #define VIS_START_Y      40    // 시작 Y 좌표
     16          #define VIS_HEIGHT      160    // 그래프 높이
     17          #define VIS_WIDTH       280    // 그래프 너비
     18          #define VIS_UPDATE_MS    50    // 업데이트 주기(ms)
     19          
     20          // 이중 버퍼링을 위한 구조체
     21          typedef struct {
     22              float32_t buffer[512];
     23              volatile uint16_t writeIdx;
     24              volatile uint16_t readIdx;
     25              volatile uint8_t isFull;
     26          } AudioBuffer;
     27          
     28          AudioBuffer audioBuffer = {0};
     29          
     30          // 시각화 관련 전역 변수
     31          typedef struct {
     32              uint8_t bars[VIS_BAR_COUNT];  // 각 막대의 높이
     33              uint32_t lastUpdateTime;       // 마지막 업데이트 시간
     34              uint8_t mode;                  // 시각화 모드 (0: 볼륨, 1: 베이스, 2: 믹스)
     35              uint8_t active;                // 활성화 상태
     36          } VisualizerState;
     37          
     38          VisualizerState vis = {0};
     39          
     40          // FFT 화면 모드 플래?? 추가
     41          volatile uint8_t func_mode = 0;         // 기능 선택 모드
     42          volatile uint8_t fft_display_mode = 0;  // 0: 일반 화면, 1: FFT 화면
     43          volatile uint8_t fft_update_flag = 0;   // FFT 업데이트 플래그
     44          volatile uint8_t saved_func_mode = 0;   // 이전 func_mode 저장 변수
     45          
     46          void TFT_filename(void);                          // Display MP3 file name, number, size
     47          void TFT_volume(void);                            // Display volume
     48          void TFT_bass(void);                              // Display bass
     49          void TFT_treble(void);                            // Display treble
     50          void Check_valid_increment_file(void);            // Check if valid file for increment
     51          void Check_valid_decrement_file(void);            // Check if valid file for decrement
     52          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte);  // Display MP3 file bitrate
     53          
     54          void FFT_Init(void);                              // FFT 초기화
     55          void Process_FFT(void);                           // FFT 처리
     56          void Draw_Spectrum(float32_t* data, uint16_t size, uint16_t color);// FFT 결과 그래픽 출력
     57          void PushAudioData(uint8_t* data, uint16_t len);  // 오디오 데이터 버퍼에 저장
     58          unsigned char Icon_input(void);                   // Input touch screen icon
     59          
     60          void Display_Normal_Screen(void);                 // 일반 화면 표시 함수
     61          void Init_FFT_Screen(void);                       // FFT 화면 초기화
     62          void Read_PCM_Data(void);                         // PCM 데이터 읽기 함수
     63          
     64          void Visualizer_Init(void);                       // 시각화 초기화
     65          void Visualizer_DrawScreen(void);                 // 시각화 화면 초기화
     66          void Visualizer_UpdateBars(void);                 // 막대 그래프 업데이트
     67          void Visualizer_Update(void)
     68          
     69          unsigned char total_file;                         // Total file number
                 ^
Error[Pe130]: expected a "{"
     70          unsigned char file_number = 0;                    // Current file number
     71          
     72          // 시스템 타이머 틱 카운트 변수
     73          static volatile uint32_t SystemTicks = 0;
     74          
     75          // 시스템 타이머 초기화 함수
     76          void SystemTick_Init(void) {
                                            ^
Warning[Pe012]: parsing restarts here after previous syntax error
     77              // SysTick 설정 (1ms 간격)
     78              SysTick->LOAD = (SystemCoreClock / 1000) - 1;
     79              SysTick->VAL = 0;
     80              SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
     81                              SysTick_CTRL_TICKINT_Msk |
     82                              SysTick_CTRL_ENABLE_Msk;
     83          }
     84          
     85          // GetTick 함수 구현
     86          uint32_t GetTick(void) {
     87              return SystemTicks;
                            ^
Error[Pe020]: identifier "SystemTicks" is undefined
     88          }
     89          
     90          int main(void) {
     91            unsigned char i, key;
     92            unsigned char func_mode = 0;                  // Function key mode
     93            unsigned char play_flag = 0;                  // Play or stop flag
     94            unsigned short index = 512;                   // Byte index in a sector
     95            unsigned short loop = 0;                      // MP3 play loop counter
     96            unsigned int playPercentage;                  // Play percentage
     97          
     98            unsigned int MP3_start_sector[MAX_FILE];      // MP3 file start sector
     99            unsigned int MP3_start_backup[MAX_FILE];
    100            unsigned char MP3buffer[512];                 // MP3 data from SD card
    101            unsigned int MP3_end_sector;                  // MP3 file end sector
    102          
    103            unsigned short time, stereo;                  // Decode time and mono/stereo
    104            unsigned short HDAT1, HDAT0;                  // MP3 file frame header information data
    105          
    106            Initialize_MCU();                             // Initialize MCU and kit
    107            Delay_ms(50);                                 // Wait for system stabilization
    108            Initialize_LCD();                             // Initialize text LCD module
    109            Initialize_TFT_LCD();                         // Initialize TFT-LCD module
    110            Initialize_touch_screen();                    // Initialize touch screen
    111          
    112            LCD_string(0x80, " OK-STM746 V1.0 ");         // Display title
    113            LCD_string(0xC0, "   Exp20_2.c    ");
    114          
    115            TFT_string(0, 4, Green, Black, "****************************************");
    116            TFT_string(0, 6, White, Black, "                OH-IN-PE-               ");
    117            TFT_string(0, 8, Green, Black, "****************************************");
    118            TFT_string(0, 23, Cyan, Black, "           SD 카드 초기화...            ");
    119            Beep();
    120            Delay_ms(1000);
    121            TFT_clear_screen();
    122          
    123            Initialize_SD();                              // Initialize SD card
    124            Initialize_FAT32();                           // Initialize FAT32 file system
    125            Initialize_VS1053b();                         // Initialize VS1053b
    126            Delay_ms(1000);
    127          
    128            volume = 175;                                 // Initial volume = 175/250(70%)
    129            VS1053b_SetVolume(volume);
    130            Delay_ms(1);
    131            bass = 10;                                    // Initial bass = 10 and treble = 5
    132            treble = 5;
    133            VS1053b_SetBassTreble(bass, treble);
    134          
    135            TFT_clear_screen();                           // Display basic screen
    136            TFT_string(0, 0, White, Magenta, "  OH-IN-PE-  ");
    137            TFT_string(0, 3, Cyan, Black, "----------------------------------------");
    138            TFT_string(0, 5, Magenta, Black, ">>");
    139            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    140            TFT_string(0, 9, Cyan, Black, "      파일 번호 : 000/000 (   kbps)     ");
    141            TFT_string(0,11, Cyan, Black, "      파일 용량 : 0000KB  (     Hz)     ");
    142            TFT_string(0,13, Cyan, Black, "      연주 진행 : 00:00(000%)   (      )");
    143            TFT_string(0,15, Cyan, Black, "----------------------------------------");
    144            TFT_string(0,17, Green, Black, "   음량(Volume) : 000%(000/250)         ");
    145            TFT_string(0,19, Green, Black, "   저음(Bass)   :  00 (00 ~ 15)         ");
    146            TFT_string(0,21, Green, Black, "   고음(Treble) :  00 (-8 ~ +7)         ");
    147            TFT_string(0,23, Cyan, Black, "----------------------------------------");
    148            TFT_string(0,25, Cyan, Black, "   KEY1      KEY2      KEY3      KEY4   ");
    149            TFT_string(0,27, Magenta, Black, "  (PLAY)    (FUNC)     (INC)     (DEC)  ");
    150            TFT_string(27,11, Yellow, Black, "00000");
    151            TFT_string(18,13, Magenta, Black, "00");
    152            TFT_string(21,13, Magenta, Black, "00");
    153            TFT_string(33,13, Magenta, Black, " 정지 ");
    154          
    155            Rectangle(12, 196, 67, 235, Yellow);          // Display touch key outline
    156            Rectangle(92, 196, 147, 235, Yellow);
    157            Rectangle(176, 196, 231, 235, Yellow);
    158            Rectangle(256, 196, 311, 235, Yellow);
    159          
    160            TFT_volume();                                 // Display initial play value
    161            TFT_bass();
    162            TFT_treble();
    163          
    164            total_file = fatGetDirEntry(FirstDirCluster); // Get total file number
                   ^
Error[Pe020]: identifier "total_file" is undefined
    165          
    166            for (i = 0; i < total_file; i++) {            // Get start address of all files
    167              MP3_start_sector[i] = fatClustToSect(file_start_cluster[i]);
    168                MP3_start_backup[i] = MP3_start_sector[i];
    169              }
    170          
    171            TFT_xy(22, 9);                                // Display total file number
    172            TFT_color(Yellow, Black);
    173            TFT_unsigned_decimal(total_file, 1, 3);
    174            file_number = 0;                              // Display first file name
                   ^
Error[Pe020]: identifier "file_number" is undefined
    175            TFT_filename();
    176            Check_valid_increment_file();
    177          
    178            MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    179          
    180            while(1) {
    181              if(vis.active) {
    182                  Visualizer_Update();
    183              }
    184              else {
    185                  // 기존 MP3 플레이어 코드
    186                  if (((GPIOC->IDR & 0x0080) == 0x0080) && (play_flag == 1)) {
    187                      if (index == 512) {
    188                          if (MP3_end_sector == MP3_start_sector[file_number]) {
    189                              if (file_number != (total_file - 1))
    190                                  file_number++;
    191                              else if (file_number == (total_file - 1))
    192                                  file_number = 0;
    193              
    194                              TFT_filename();
    195                              Check_valid_increment_file();
    196              
    197                              MP3_start_sector[file_number] = MP3_start_backup[file_number];
    198                              MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    199                              VS1053b_software_reset();  // VS1053b software reset to change music file
    200                          }
    201                          index = 0;
    202                          SD_read_sector(MP3_start_sector[file_number]++, MP3buffer);
    203                      }
    204              
    205                      for (i = 0; i < 32; i++) {           // Send 32 data bytes
    206                          GPIOC->BSRR = 0x00400000;        // -MP3_DCS = 0
    207                          SPI3_write(MP3buffer[index++]);  // Write a byte of MP3 data to VS1053b
    208                          GPIOC->BSRR = 0x00000040;        // -MP3_DCS = 1
    209                      }
    210                  }
    211              
    212                  // 일반 화면 업데이트는 FFT 모드가 아닐 때만 수행
    213                  if (!fft_display_mode) {
    214                      loop++;
    215                      if ((extension == 0x004D5033) && (loop == 250) && (play_flag == 1)) {
    216                          HDAT1 = VS1053b_SCI_Read(0x09);
    217                          HDAT0 = VS1053b_SCI_Read(0x08);
    218              
    219                          if ((HDAT1 & 0xFFE0) == 0xFFE0)
    220                              if (((HDAT1 & 0x0006) != 0x0000) && ((HDAT0 & 0x0C00) != 0x0C00))
    221                                  TFT_MP3_bitrate(HDAT1, HDAT0);
    222                      } else if ((loop == 500) && (play_flag == 1)) {
    223                          loop = 0;
    224              
    225                          time = VS1053b_SCI_Read(0x04);       // Decode time
    226                          TFT_xy(18, 13);
    227                          TFT_color(Magenta, Black);
    228                          TFT_unsigned_decimal(time / 60, 1, 2);
    229                          TFT_xy(21, 13);
    230                          TFT_unsigned_decimal(time % 60, 1, 2);
    231              
    232                          playPercentage = MP3_end_sector - MP3_start_sector[file_number];
    233                          playPercentage = (unsigned int)((float)playPercentage / (float)(file_size[file_number] >> 9) * 100.);
    234                          playPercentage = 100 - playPercentage;
    235              
    236                          TFT_xy(24, 13);                      // Display play percentage
    237                          TFT_color(Yellow, Black);
    238                          if (playPercentage >= 100)
    239                              TFT_unsigned_decimal(playPercentage, 0, 3);
    240                          else if (playPercentage >= 10)
    241                              TFT_unsigned_decimal(playPercentage, 0, 2);
    242                          else
    243                              TFT_unsigned_decimal(playPercentage, 0, 1);
    244                          TFT_color(Cyan, Black);
    245                          TFT_English('%');
    246                          TFT_English(')');
    247                          TFT_English(' ');
    248                          TFT_English(' ');
    249              
    250                          stereo = VS1053b_SCI_Read(0x05);
    251                          TFT_xy(27, 11);                      // Sampling rate
    252                          TFT_color(Yellow, Black);
    253                          TFT_unsigned_decimal(stereo >> 1, 0, 5);
    254                          if ((stereo & 0x0001) == 0x0001) {   // Channel mode = stereo
    255                              TFT_string(32, 17, Cyan, Black, "(");
    256                              TFT_string(33, 17, Yellow, Black, "stereo");
    257                              TFT_string(39, 17, Cyan, Black, ")");
    258                          } else {                             // Channel mode = mono
    259                              TFT_string(32, 17, Cyan, Black, "(");
    260                              TFT_string(33, 17, Yellow, Black, " mono ");
    261                              TFT_string(39, 17, Cyan, Black, ")");
    262                          }
    263                      }
    264                  } else {
    265                      // FFT 모드일 때 시각화 업데이트 수행
    266                      if (fft_update_flag) {
    267                          fft_update_flag = 0;
    268                          Visualizer_UpdateBars();
    269                      }
    270                  }
    271              }
    272              
    273              // 키 입력 처리
    274              key = Key_input();
    275              if(key == no_key) {
    276                  key = Icon_input();
    277              }
    278              
    279              // 키 처리
    280              switch(key) {
    281                  case KEY1:
    282                    play_flag ^= 0x01;               // Toggle play or stop
    283                    if (play_flag == 1)
    284                      TFT_string(33, 13, Yellow, Black, "재생중");
    285                    else
    286                      TFT_string(33, 13, Magenta, Black, " 정지 ");
    287                    break;
    288            
    289                  case KEY2:
    290                    if (func_mode == 0) {            // Select function
    291                      func_mode = 1;
    292                      TFT_string(0, 5, Magenta, Black, "  ");
    293                      TFT_string(0,17, Magenta, Black, ">>");
    294                    } else if (func_mode == 1) {
    295                      func_mode = 2;
    296                      TFT_string(0,17, Magenta, Black, "  ");
    297                      TFT_string(0,19, Magenta, Black, ">>");
    298                    } else if (func_mode == 2) {
    299                      func_mode = 3;
    300                      TFT_string(0,19, Magenta, Black, "  ");
    301                      TFT_string(0,21, Magenta, Black, ">>");
    302                    } else {
    303                      func_mode = 0;
    304                      TFT_string(0,21, Magenta, Black, "  ");
    305                      TFT_string(0, 5, Magenta, Black, ">>");
    306                           }
    307                        break;
    308            
    309                  // key3 입력 시 각 기능의 값 증가, 최대값에 도달하면 최소값으로 돌아감
    310                  case KEY3:
    311                      if (func_mode == 0) {            // 다음 음악 선택
    312                          if (file_number != (total_file - 1))
    313                              file_number++;
    314                          else
    315                              file_number = 0;
    316            
    317                          VS1053b_software_reset();
    318                          TFT_filename();
    319                          Check_valid_increment_file();
    320            
    321                          MP3_start_sector[file_number] = MP3_start_backup[file_number];
    322                          MP3_end_sector = (file_size[file_number] >> 9) + MP3_start_sector[file_number];
    323                          index = 512;
    324                          VS1053b_software_reset();
    325                      } else if (func_mode == 1) {     // 볼륨 증가
    326                          volume++;
    327                          if (volume > 250) {
    328                              volume = 5;  // 최소값으로 돌아감
    329                          }
    330                          VS1053b_SetVolume(volume);
    331                          TFT_volume();
    332                      } else if (func_mode == 2) {     // 베이스 증가
    333                          bass++;
    334                          if (bass > 15) {
    335                              bass = 0;  // 최소값으로 돌아감
    336                          }
    337                          VS1053b_SetBassTreble(bass, treble);
    338                          TFT_bass();
    339                      } else {                         // 트레블 증가
    340                          treble++;
    341                          if (treble > 7) {
    342                              treble = -8;  // 최소값으로 돌아감
    343                          }
    344                          VS1053b_SetBassTreble(bass, treble);
    345                          TFT_treble();
    346                      }
    347                      break;
    348            
    349                  case KEY4:
    350                      if(!vis.active) {  // Visualizer 모드 진입
    351                          vis.active = 1;
    352                          Visualizer_Init();
    353                      }
    354                      else {  // 모드 변경 또는 종료
    355                          vis.mode++;
    356                          if(vis.mode > 2) {  // 모드 순환이 끝나면 종료
    357                              vis.active = 0;
    358                              vis.mode = 0;
    359                              Display_Normal_Screen();  // 일반 화면으로 복귀
    360                          }
    361                      }
    362                      break;
    363            
    364                  default:
    365                    break;
    366              }
    367              
    368            }
    369          }
    370          
    371          /* User-defined functions */
    372          
    373          void TFT_filename(void) {
    374            unsigned char file_flag;
    375            unsigned short file_KB;
    376          
    377            TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    378            TFT_string(3, 5, Green, Black, "                                     ");
    379          
    380            file_flag = Get_long_filename(file_number);   // Check file name
                                                 ^
Error[Pe020]: identifier "file_number" is undefined
    381          
    382            if (file_flag == 0)                           // Short file name (8.3 format)
    383              TFT_short_filename(3, 5, Green, Black);
    384            else if (file_flag == 1)                      // Long file name
    385              TFT_long_filename(3, 5, Green, Black);
    386            else if (file_flag == 2)                      // File name is longer than 195 characters
    387              TFT_string(3, 5, Red, Black, "* 파일명 길이 초과 *");
    388            else                                          // File name error
    389              TFT_string(3, 5, Red, Black, "*** 파일명 오류 ***");
    390          
    391            file_KB = file_size[file_number] / 1024;      // Calculate file size in KB
    392            if ((file_size[file_number] % 1024) != 0)
    393              file_KB++;
    394          
    395            if (file_flag != 3) {
    396              TFT_xy(18, 9);                            // File number
    397                TFT_color(Magenta, Black);
    398              TFT_unsigned_decimal(file_number + 1, 1, 3);
    399              TFT_xy(17,11);                            // File size
    400                TFT_color(Magenta, Black);
    401              TFT_unsigned_decimal(file_KB, 0, 5);
    402              }
    403          
    404            TFT_string(27, 9, Yellow, Black, "000");      // Clear bitrate
    405          
    406            TFT_xy(24, 13);                               // Display percentage = 0
    407            TFT_color(Yellow, Black);
    408            TFT_English('0');
    409            TFT_color(Cyan, Black);
    410            TFT_English('%');
    411            TFT_English(')');
    412            TFT_English(' ');
    413            TFT_English(' ');
    414          }
    415          
    416          void TFT_volume(void) {
    417            TFT_xy(18, 17);
    418            TFT_color(Magenta, Black);
    419            TFT_unsigned_decimal((unsigned int)(volume * 100.0 / 250.0 + 0.5), 0, 3);
    420            TFT_xy(23, 17);
    421            TFT_color(Yellow, Black);
    422            TFT_unsigned_decimal(volume, 1, 3);
    423          }
    424          
    425          void TFT_bass(void) {
    426            TFT_xy(19, 19);
    427            TFT_color(Magenta, Black);
    428            TFT_unsigned_decimal(bass, 1, 2);
    429          }
    430          
    431          void TFT_treble(void) {
    432            TFT_xy(19, 21);
    433            TFT_color(Magenta, Black);
    434            TFT_signed_decimal(treble, 0, 1);
    435          }
    436          
    437          void Check_valid_increment_file(void) {
    438            unsigned char file_OK_flag = 0;
    439            do {
    440              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    441                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    442                if (file_number != (total_file - 1))
                           ^
Error[Pe020]: identifier "file_number" is undefined

        if (file_number != (total_file - 1))
                            ^
"C:\IAR Systems\oh-in-pe-\main.c",442  Error[Pe020]: identifier "total_file" is
          undefined
    443          	    file_number++;
    444          	  else
    445          	    file_number = 0;
    446                    TFT_filename();
    447              } else {
    448                  file_OK_flag = 1;
    449              }
    450            } while (file_OK_flag == 0);
    451          }
    452          
    453          void Check_valid_decrement_file(void) {
    454            unsigned char file_OK_flag = 0;
    455            do {
    456              if ((extension != 0x004D5033) && (extension != 0x00414143) &&
    457                (extension != 0x00574D41) && (extension != 0x004D4944)) {
    458                if (file_number != 0)
                           ^
Error[Pe020]: identifier "file_number" is undefined
    459          	    file_number--;
    460          	  else
    461          	    file_number = total_file - 1;
                 	                  ^
Error[Pe020]: identifier "total_file" is undefined
    462                    TFT_filename();
    463              } else {
    464                  file_OK_flag = 1;
    465              }
    466            } while (file_OK_flag == 0);
    467          }
    468          
    469          void TFT_MP3_bitrate(U16 highbyte, U16 lowbyte) {
    470            unsigned short MPEG10_Layer1[16] = {
    471              0, 32, 64, 96, 128, 160, 192, 224,
    472              256, 288, 320, 352, 384, 416, 448, 0
    473            };
    474            unsigned short MPEG10_Layer2[16] = {
    475              0, 32, 48, 56, 64, 80, 96, 112,
    476              128, 160, 192, 224, 256, 320, 384, 0
    477            };
    478            unsigned short MPEG10_Layer3[16] = {
    479              0, 32, 40, 48, 56, 64, 80, 96,
    480              112, 128, 160, 192, 224, 256, 320, 0
    481            };
    482            unsigned short MPEG20_Layer1[16] = {
    483              0, 32, 48, 56, 64, 80, 96, 112,
    484              128, 144, 160, 176, 192, 224, 256, 0
    485            };
    486            unsigned short MPEG20_Layer2[16] = {
    487              0, 8, 16, 24, 32, 40, 48, 56,
    488              64, 80, 96, 112, 128, 144, 160, 0
    489            };
    490          
    491            if ((highbyte & 0x0018) == 0x0018) {              // MPEG-1.0
    492              switch (highbyte & 0x0006) {
    493                case 0x0002:                              // Layer-3
    494                  TFT_xy(27, 9);
    495                  TFT_color(Yellow, Black);
    496                  TFT_unsigned_decimal(MPEG10_Layer3[lowbyte >> 12], 1, 3);
    497          		        break;
    498                case 0x0004:                              // Layer-2
    499                  TFT_xy(27, 9);
    500                  TFT_color(Yellow, Black);
    501                  TFT_unsigned_decimal(MPEG10_Layer2[lowbyte >> 12], 1, 3);
    502          		        break;
    503                case 0x0006:                              // Layer-1
    504                  TFT_xy(27, 9);
    505                  TFT_color(Yellow, Black);
    506                  TFT_unsigned_decimal(MPEG10_Layer1[lowbyte >> 12], 1, 3);
    507          		        break;
    508          	}
    509            } else if ((highbyte & 0x0018) == 0x0010) {       // MPEG-2.0
    510              switch (highbyte & 0x0006) {
    511                case 0x0002:                              // Layer-3
    512                  TFT_xy(27, 9);
    513                  TFT_color(Yellow, Black);
    514                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    515          		        break;
    516                case 0x0004:                              // Layer-2
    517                  TFT_xy(27, 9);
    518                  TFT_color(Yellow, Black);
    519                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    520          		        break;
    521                case 0x0006:                              // Layer-1
    522                  TFT_xy(27, 9);
    523                  TFT_color(Yellow, Black);
    524                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    525          		        break;
    526          	}
    527            } else {                                          // MPEG-2.5
    528              switch (highbyte & 0x0006) {
    529                case 0x0002:                              // Layer-3
    530                  TFT_xy(27, 9);
    531                  TFT_color(Yellow, Black);
    532                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    533          		        break;
    534                case 0x0004:                              // Layer-2
    535                  TFT_xy(27, 9);
    536                  TFT_color(Yellow, Black);
    537                  TFT_unsigned_decimal(MPEG20_Layer2[lowbyte >> 12], 1, 3);
    538          		        break;
    539                case 0x0006:                              // Layer-1
    540                  TFT_xy(27, 9);
    541                  TFT_color(Yellow, Black);
    542                  TFT_unsigned_decimal(MPEG20_Layer1[lowbyte >> 12], 1, 3);
    543          		        break;
    544          	}
    545              }
    546          }
    547          
    548          unsigned char icon_flag = 0;
    549          
    550          unsigned char Icon_input(void) {
    551            unsigned char keyPressed;
    552          
    553            Touch_screen_input();                          // Input touch screen
    554          
    555            if ((icon_flag == 0) && (x_touch >= 12) && (x_touch <= 67) &&
    556              (y_touch >= 196) && (y_touch <= 235)) {
    557              keyPressed = KEY1;
    558                icon_flag = 1;
    559              // Rectangle(12, 196, 67, 235, Magenta);
    560          
    561            } else if ((icon_flag == 0) && (x_touch >= 92) && (x_touch <= 147) &&
    562                   (y_touch >= 196) && (y_touch <= 235)) {
    563              keyPressed = KEY2;
    564                icon_flag = 1;
    565              // Rectangle(92, 196, 147, 235, Magenta);
    566          
    567            } else if ((icon_flag == 0) && (x_touch >= 176) && (x_touch <= 231) &&
    568                   (y_touch >= 196) && (y_touch <= 235)) {
    569              keyPressed = KEY3;
    570                icon_flag = 1;
    571              // Rectangle(176, 196, 231, 235, Magenta);
    572          
    573            } else if ((icon_flag == 0) && (x_touch >= 256) && (x_touch <= 311) &&
    574                   (y_touch >= 196) && (y_touch <= 235)) {
    575              keyPressed = KEY4;
    576                icon_flag = 1;
    577              // Rectangle(256, 196, 311, 235, Magenta);
    578          
    579            } else if ((icon_flag == 1) && (x_touch == 0) && (y_touch == 0)) {
    580              keyPressed = no_key;
    581                icon_flag = 0;
    582              // Rectangle(12, 196, 67, 235, Yellow);
    583              // Rectangle(92, 196, 147, 235, Yellow);
    584              // Rectangle(176, 196, 231, 235, Yellow);
    585              // Rectangle(256, 196, 311, 235, Yellow);
    586                Delay_ms(50);
    587            } else {
    588              keyPressed = no_key;
    589            }
    590          
    591            return keyPressed;
    592          }
    593          
    594          
    595          // 오디오 데이터 버퍼링 함수
    596          void PushAudioData(uint8_t* data, uint16_t len) {
    597              for(uint16_t i = 0; i < len; i++) {
    598                  audioBuffer.buffer[audioBuffer.writeIdx] = ((float32_t)data[i] - 128.0f) / 128.0f;
    599                  audioBuffer.writeIdx = (audioBuffer.writeIdx + 1) % 512;
    600                  if(audioBuffer.writeIdx == audioBuffer.readIdx) {
    601                      audioBuffer.isFull = 1;
    602                  }
    603              }
    604          }
    605          
    606          // 일반 화면 표시 함수
    607          void Display_Normal_Screen(void) {
    608              TFT_clear_screen();
    609              TFT_string(0, 0, White, Magenta, "  OH-IN-PE-  ");
    610              TFT_string(0, 3, Cyan, Black, "----------------------------------------");
    611              TFT_string(0, 5, Magenta, Black, ">>");
    612              TFT_string(0, 7, Cyan, Black, "----------------------------------------");
    613              TFT_string(0, 9, Cyan, Black, "      파일 번호 : 000/000 (   kbps)     ");
    614              TFT_string(0,11, Cyan, Black, "      파일 용량 : 0000KB  (     Hz)     ");
    615              TFT_string(0,13, Cyan, Black, "      연주 진행 : 00:00(000%)   (      )");
    616              TFT_string(0,15, Cyan, Black, "----------------------------------------");
    617              TFT_string(0,17, Green, Black, "   음량(Volume) : 000%(000/250)         ");
    618              TFT_string(0,19, Green, Black, "   저음(Bass)   :  00 (00 ~ 15)         ");
    619              TFT_string(0,21, Green, Black, "   고음(Treble) :  00 (-8 ~ +7)         ");
    620              TFT_string(0,23, Cyan, Black, "----------------------------------------");
    621              TFT_string(0,25, Cyan, Black, "   KEY1      KEY2      KEY3      KEY4   ");
    622              TFT_string(0,27, Magenta, Black, "  (PLAY)    (FUNC)     (INC)     (DEC)  ");
    623              
    624              // 현재 상태 업데이트
    625              TFT_filename();
    626              TFT_volume();
    627              TFT_bass();
    628              TFT_treble();
    629          }
    630          
    631          void Visualizer_Init(void) {
    632              memset(&vis, 0, sizeof(VisualizerState));
    633              vis.active = 1;
    634              TFT_clear_screen();
    635              
    636              // 제목 및 기본 UI 표시
    637              TFT_string(0, 0, White, Magenta, "  Music Visualizer  ");
    638              TFT_string(0, 2, Green, Black, "========================================");
    639              
    640              // 그래프 영역 테두리
    641              Rectangle(VIS_START_X - 5, VIS_START_Y - 5,
    642                       VIS_START_X + VIS_WIDTH + 5, 
    643                       VIS_START_Y + VIS_HEIGHT + 5, White);
    644                       
    645              // 모드 표시
    646              TFT_string(0, 27, Cyan, Black, "VOL    BASS    MIX    EXIT");
    647          }
    648          void Visualizer_Update(void) {
                      ^
Error[Pe247]: function "Visualizer_Update" has already been defined (at line
          67)
    649              static const float SMOOTHING = 0.7f;  // 스무딩 계수
    650              
    651              // 업데이트 주기 체크
    652              uint32_t currentTime = GetTick();
    653              if(currentTime - vis.lastUpdateTime < VIS_UPDATE_MS) {
    654                  return;
    655              }
    656              vis.lastUpdateTime = currentTime;
    657          
    658              // VS1053b 레지스터 읽기
    659              uint16_t volumeReg = VS1053b_SCI_Read(0x0B);
    660              uint16_t soundReg = VS1053b_SCI_Read(0x02);
    661              
    662              // 볼륨, 베이스, 트레블 값 추출
    663              uint8_t volume = 254 - (volumeReg & 0xFF);
    664              uint8_t bass = (soundReg >> 4) & 0x0F;
    665              int8_t treble = (soundReg >> 12) & 0x0F;
    666          
    667              // 각 막대 업데이트
    668              for(int i = 0; i < VIS_BAR_COUNT; i++) {
    669                  uint8_t newHeight;
    670                  
    671                  switch(vis.mode) {
    672                      case 0:  // 볼륨 모드
    673                          newHeight = (volume * VIS_HEIGHT) / 254;
    674                          newHeight += (rand() % 20) - 10;  // 랜덤 효과
                                               ^
Warning[Pe223]: function "rand" declared implicitly
    675                          break;
    676                          
    677                      case 1:  // 베이스 모드
    678                          newHeight = (bass * VIS_HEIGHT) / 15;
    679                          if(i < VIS_BAR_COUNT/2) {
    680                              newHeight += (volume * VIS_HEIGHT) / 508;  // 볼륨 영향 절반
    681                          }
    682                          newHeight += (rand() % 15) - 7;
    683                          break;
    684                          
    685                      case 2:  // 믹스 모드
    686                          newHeight = ((volume + (bass * 16) + 
    687                                     ((treble + 8) * 16)) * VIS_HEIGHT) / 
    688                                     (254 + 240 + 240);
    689                          newHeight += (rand() % 25) - 12;
    690                          break;
    691                  }
    692                  
    693                  // 범위 제한
    694                  if(newHeight > VIS_HEIGHT) newHeight = VIS_HEIGHT;
    695                  
    696                  // 스무딩 적용
    697                  vis.bars[i] = (uint8_t)(vis.bars[i] * SMOOTHING + 
    698                                         newHeight * (1.0f - SMOOTHING));
    699                  
    700                  // 막대 그리기
    701                  uint16_t x = VIS_START_X + (i * (VIS_BAR_WIDTH + VIS_BAR_SPACING));
    702                  uint16_t color;
    703                  
    704                  // 모드별 다른 색상 적용
    705                  switch(vis.mode) {
    706                      case 0: color = RGB(vis.bars[i], 0, vis.bars[i]); break;  // 보라색 계열
                                             ^
Warning[Pe223]: function "RGB" declared implicitly
    707                      case 1: color = RGB(0, 0, vis.bars[i]); break;            // 파란색 계열
    708                      case 2: color = RGB(0, vis.bars[i], vis.bars[i]); break;  // 청록색 계열
    709                  }
    710                  
    711                  // 이전 막대 지우기
    712                  Rectangle(x, VIS_START_Y, 
    713                           x + VIS_BAR_WIDTH, 
    714                           VIS_START_Y + VIS_HEIGHT, Black);
    715                  
    716                  // 새 막대 그리기
    717                  Rectangle(x, VIS_START_Y + VIS_HEIGHT - vis.bars[i],
    718                           x + VIS_BAR_WIDTH, 
    719                           VIS_START_Y + VIS_HEIGHT, color);
    720              }
    721          }

Errors: 10
Warnings: 3
